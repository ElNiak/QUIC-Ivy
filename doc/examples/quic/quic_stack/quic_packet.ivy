#lang ivy1.7

include quic_types
include quic_frame
include quic_transport_parameters
include ip

# QUIC Packets
# ------------

# This section defines the QUIC packet datatype. Packets are the basic
# unit of communication between endpoints. A packet has a *type*,
# associated cid, an optional protocol version, and a packet
# number. The *payload* of the packet consists of a sequence of
# *frames* (see frame.ivy). A packet may be encoded in either *long*
# or *short* format.
# 

# TODO: not needed?
# object quic_long_type = {
#    type this = {initial,retry,handshake,zero_rtt_protected}
# }

# ### Packet

# The type `quic_packet` represents packet. 

# The fields are:
#
# - *hdr_long*: true if the packet has long format [1]
# - *hdr_type*: the packet type bits [2]
# - *hdr_cid*: the associated cid [3]
# - *hdr_version*: the protocol version, or zero for short format
# - *hdr_pkt_num*: the packet number
# - *hdr_token_length*: the retry token length (see section 4.4.1)
# - *hdr_token*: the retry token  (see section 4.4.1)
# - *payload*: the payload, a sequence of frames

object quic_packet = {
    type this = struct {
        hdr_long : bool, # [1]
        hdr_type : type_bits, # [2]
        hdr_version : version, # [4]
        dcid : cid_length, 
        scid : cid_length, 
        dst_cid : cid,
        hdr_cid : cid, # [3]
        hdr_token_length : stream_pos,
        hdr_token : stream_data,
        payload_length : stream_pos,
        hdr_pkt_num : pkt_num, # [5]
        payload : frame.arr # [6]
    }

    instance idx : unbounded_sequence
    instance arr : array(idx,this)
}


# Protocol state
# ==============

# This section desceibes the history variables that track the state of
# the various protocol layers. Some of these variables are sharded between
# protocol layers, so that the allowed interleavings of events at different
# layers can be specified.
#

# Packet protocol state
# ---------------------

# - For each cid C, `conn_seen(C)` is true if a packet with
#   source cid C has been transmitted.
#
# - For each aid C, `conn_closed(C)` is true if C is in the closed state.
#
# - For each aid C, `conn_draining(C)` is true if C is in the draining state.
#
# - For each aid C, `draining_pkt_sent(C)` is true if the single
#   packet allowed to be sent in transition to the draining state has been sent.
#   This one packet must contain a connection_close frame with error code 0.
#   TODO: we don't check the error code.
#
# - For each endpoint aid C, last_pkt_num(C,L) represents the
#   number of the latest packet sent by C in encryption level L.
#
# - For each aid C, sent_pkt(C,L,N) is true if
#   a packet numbered N has been sent by C in encryption level L.
#
# - For each aid C, acked_pkt(C,L,N) is true if
#   a packet numbered N sent by C in encryption level L has been
#   acknowledged. 
#
# - For each aid C, max_acked(C,L) is the greatest
#   packet number N such that acked_pkt(C,L,N), or zero if
#   forall N. ~acked(C,L,N).
#
# - For each aid C, ack_credit(E,C) is the number
#   of non-ack-only packets sent to C, less the number of
#   ack-only packets sent from C.
#
# - For each aid C, `trans_params_set(C)`
#   is true if C has declared transport parameters.
#
# - For each aid C, function `trans_params(C)`
#   gives the transport parameters declared by C.
#
# - The predicate `cid_dst_to_src_set(C)` indicates that the peer of
#   aid `C` has been determined.  This occurs conceptually when a
#   server produces a server hello frame.
#
# - The function `cid_dst_to_src(C)` maps the aid `C` to its peer, if
#   the peer has been determined.
#
# - The predicate `is_client(C)` indicates that aid 'C' is taking
#   the client role.
#
# - The predicate `conn_requested(S,D,C)` indicates that a client
#   and endpoint S has requested to open a connection with a server
#   at endpoint D, using cid C. 
#
# - The function `hi_non_probing(C)` indicates the highest packet number
#   of a non-probing packet sent by aid `C`. 
# 
# - The relation `hi_non_probing_endpoint(C,E)` that the highest-numbered
#   non-probing packet of aid `C` was at some time sent from endpopint `E`.
#
# - The function `conn_total_data(C)` represents the total number of stream
#   bytes received by aid `C`.
#
# - The relation `pkt_has_close(C,L,N)` is true if packet number `N` sent 
#   by aid `C` contained a CONNECTION_CLOSE frame.
#
# - The relation cid_mapped(C) is true when connection ID C has been provided as new connection ID for a connection
#   and becomes false when the C is retired
#
# - If cid_mapped(C) is true, then the function cid_to_aid(C) gives the aid for which C is a new connection ID
#

relation conn_seen(C:cid)
relation conn_closed(C:cid)
relation conn_draining(C:cid)
relation draining_pkt_sent(C:cid)
function last_pkt_num(C:cid,L:encryption_level) : pkt_num
relation sent_pkt(C:cid,L:encryption_level,N:pkt_num)
relation acked_pkt(C:cid,L:encryption_level,N:pkt_num)
function max_acked(C:cid,L:encryption_level) : pkt_num
function ack_credit(C:cid) : pkt_num
relation trans_params_set(C:cid)
function trans_params(C:cid) : trans_params_struct
relation cid_dst_to_src_set(C:cid)
function cid_dst_to_src(C:cid) : cid
relation is_client(C:cid)
relation conn_requested(S:ip.endpoint,D:ip.endpoint,C:cid)
function hi_non_probing(C:cid) : pkt_num
relation hi_non_probing_endpoint(C:cid,E:ip.endpoint)
#function conn_total_data(C:cid) : stream_pos
relation pkt_has_close(C:cid,L:encryption_level,N:pkt_num)

# added
function cid_to_aid(C:cid) : cid 
relation cid_mapped(C : cid)

#
# Client initial request event
# ============================
#
# This event occurs when a client transmits in initial request to open
# a connection.

action client_initial_request(src:ip.endpoint,dst:ip.endpoint,pkt:quic_packet)

# Packet events
# -------------

# A packet event represents the transmision of a UDP packet `pkt` from
# QUIC source endpoint `src` to a QUIC destination endpoint `dst`
# containing a sequence of queued frames.

# The packet *kind* depends on the field `hdr_type` according to
# the following table:
#
#   | hdr_type  | kind      |
#   |-----------|-----------|
#   | 0x7f      | Initial   |
#   | 0x7d      | Handshake |
#

# ### Requirements
#
# - The packet payload may not be empty [7].
#
# - The header type must be one of the above [8].
#
# - An Initial packet represents an attempt by a client to establish a
#   connection. The scid is arbitrary, but must not have been previously
#   seen. The dcid is unspecified. The initial packet must consist (apart from padding) of a
#   single crypto, containing the initial security
#   handshake information [1].
#
# - A Handshake packet is sent in response to an Initial packet or
#   a previous Handshake. In the latter case, the dcid must match
#   the scid provided by the peer.
#
# - Initial packets may not be sent on a cid that has
#   been closed by the sender [6].
#
# - Once a cid has been renamed by the server, it may no longer be used in a packet header.
#   Instead the new cid must be used. [9]
#
# - A sender may not re-use a packet number on a given scid [4].
#
# - A packet containing only ack frames and padding is *ack-only*.
#   For a given cid, the number of ack-only packets sent from src to dst
#   must not be greater than the number of non-ack-only packets sent
#   from dst to src [5].
#
# - For a given connecitn, a server must only send packets to an
#   address that at one time in the past sent the as packet with
#   the highest packet numer thus far received. See notes below on
#   migration and path challenge. [10]

# ### Effects
#
# - The `conn_seen` and `sent_pkt` relations are updated to reflect
#   the observed packet [1].
# - The `last_pkt_num` function is updated to indicate the observed
#   packets as most recent for the packet's source and cid.
#   
#
# ### Notes
#
# - The effective packet number is computed according to the procedure
#   `decode_packet_number` defined below.
#
# - It isn't clear whether a packet that is multiply-delivered packet
#   can be responded to by multple ack-only packets. Here, we assume it
#   cannot. That is, only a new distinct packet number allows an ack-only
#   packet to be sent in response.
#
# - On see a packet form a new address with the highest packect number
#   see thus far, the server detects migration of the client. It
#   begins sending packets to this address and initiates path
#   validation for this address. Until path validation succeeds, the
#   server limits data sent to the new address. Currently we cannot specify
#   this limit because we don't know the byte size of packets or the timings
#   of packets. On detecting migration, the server abandons any pending path
#   validation of the old address. We don't specify this because the definition
#   of abandonment is not clear. In practice, we do observe path challenge frames
#   sent to old addresses, perhaps because these were previously queued. QUESTION:
#   abandoning an old path challenge could result in an attacker denying the ability
#   of the client to migrate by replaying packets, spoofing the old address.
#   The server would alternate between the old (bogus) and new address, and thus
#   never complete the path challenge of the new address. 



around packet_event(src:ip.endpoint,dst:ip.endpoint,pkt:quic_packet) {
    
    var hdr_type_bits : type_bits := bvand(pkt.hdr_type,0x30);
    # TEMPORARY
    require ~pkt.hdr_long -> bvand(pkt.hdr_type,0x5c) = 0x40; # assume fixed bit is 1, R,K = 0
    require pkt.hdr_long -> bvand(pkt.hdr_type,0x4c) = 0x40; # assume fixed bit is 1, R = 0
    require ~pkt.hdr_long -> (pkt.dcid = 5 & pkt.scid = 0);
    require pkt.hdr_long -> (pkt.dcid > 0 & pkt.scid > 0);
    require pkt.hdr_token_length = pkt.hdr_token.end;
    require pkt.hdr_token_length ~= 0 -> (pkt.hdr_long & hdr_type_bits = 0);

    # Allowed long header types (TEMPORARY)

    require pkt.hdr_long -> (hdr_type_bits = 0x20 | hdr_type_bits = 0);
    
    # Extract the source and destination cid's and packet number from the packet.

    var dcid := pkt.dst_cid;
    var scid := pkt.hdr_cid;

    #add 
    if cid_mapped(dcid) {
	    dcid := cid_to_aid(dcid);
    };

    # On long headers, both cids are given. Record the correspondence.
    # If the scid has been mapped, make sure it maps to the dcid.
    # However, this requirement does not apply to initial client hello
    # packets.

    if pkt.hdr_long {
        require cid_dst_to_src_set(scid) ->
              (cid_dst_to_src(scid) = dcid | (queued_hello(scid) & is_client(scid)))
    }

    # On short headers, the scid is not given, so we use the recorded value

    # TODO: this is not reliable for testing, since a short header might
    # arrive before a corresping long header due to packet re-ordering. We
    # need to handle this case. This is a general problem with the test setup:
    # the specification applies to packets in the actual order of transmission,
    # while the tester may receive them out-of-order. One fix for this would be
    # to have the spec also allow re-ordering, but this might introduce some
    # significant complexity.

    else {
        require cid_dst_to_src_set(dcid);
        scid := cid_dst_to_src(dcid)
    };

    var e := queued_level(scid);

    # The header type depends on the encryption level

    require e = encryption_level.initial -> pkt.hdr_long & hdr_type_bits = 0;
    require e = encryption_level.handshake -> pkt.hdr_long & hdr_type_bits = 0x20;
    require e = encryption_level.other -> ~pkt.hdr_long;
    
    var pnum := decode_packet_number(src,scid,e,pkt.hdr_pkt_num);

    call show_pstats(scid,e,pnum);

    require ~sent_pkt(scid,e,pnum);  # [4]

    # The payload may not be empty

    require num_queued_frames(scid) > 0;  # [7]

    # A packet is an initial packet iff it contains a client hello.

    # TODO: what to say about this?
    # assert pkt.hdr_type = 0x7f <-> queued_hello(scid);

    # Record that the connection has been seen from this source, and
    # the packet has been sent.

    sent_pkt(scid,e,pnum) := true;  # [1]

    # Record the packet number as latest seen

    last_pkt_num(scid,e) := pnum;

  
    # The payload must exactly match the queued frames.

    require pkt.payload = queued_frames(scid);

    # var idx : frame.idx := 0;
    # while idx < pkt.payload.end {
    #     call pkt.payload.value(idx).handle(src,dst,dcid);
    #     idx := idx + 1
    # }

    # TEMPORARY: don't allow client migration during handshake

    require conn_seen(scid) & pkt.hdr_long & is_client(scid) -> conn_requested(src,dst,scid);

    # Packet must be sent to the endpoint from which the highest numbered
    # packet has been received.

    require conn_seen(dcid) -> hi_non_probing_endpoint(dcid,dst);  # [10]

    # If this is a non-probing packet, update the highest non-probing
    # packet number seen on from this aid.
    # QUESTION: what if two differenht paths send the same packet number?
    # QUESTION: how do you compare packet numbers with different encryption levels?

    if queued_non_probing(scid) {
        if e = encryption_level.other {
            if pnum >= hi_non_probing(scid) {
                hi_non_probing(scid) := pnum;
                hi_non_probing_endpoint(scid,src) := true;
            }
        } else {
            hi_non_probing_endpoint(scid,src) := true;
        }
    };

    # TEMPORARY: do not apply ack-onlty rule to generated packets
    # This can be removed when we have a frame queue per encryption level

    require ~_generating & ~queued_non_ack(scid) -> ack_credit(scid) > 0;  # [5]

    # QUESTION: THis sentence is from draft-18 section 13.1: "An
    #   endpoint MUST NOT send a packet containing only an ACK frame
    #   in response to a packet containing only ACK or PADDING frames,
    #   even if there are packet gaps which precede the received
    #   packet." Do we interpret this to mean that an ack-only packet
    #   cannot ack *only* ack-only packets?  Or that an ack-only
    #   packet cannot ack *any* ack-only packets?
    
    # If the sender is in the draining state, this is the draining packet.
    # Make sure that a draining packet has not previously been sent and
    # that the packet contains a connection_close frame;

    if conn_draining(scid) {
        require ~draining_pkt_sent(scid) & queued_close(scid);
    };
    ...

    # TEMPORARY: The following are repeated because currently locals defined in
    # the "before" section cannot be accessed in the "after" section.

    var hdr_type_bits : type_bits := bvand(pkt.hdr_type,0x30);
    var dcid := pkt.dst_cid;
    var scid := pkt.hdr_cid;

    if cid_mapped(dcid) {
	    dcid := cid_to_aid(dcid);
    };

    if ~pkt.hdr_long {
        scid := cid_dst_to_src(dcid)
    };

    # TODO: in draft 15, application close is not allowed in an
    # initial packet. This will change in draft 17 so that it is
    # allowed, but not if the RTT-1 keys are available. 

    if pkt.hdr_long & hdr_type_bits = 0 {
        require forall (I:frame.idx) 0 <= I & I < pkt.payload.end ->
        ((pkt.payload.value(I) isa frame.ack)
        | (pkt.payload.value(I) isa frame.crypto)
        | (pkt.payload.value(I) isa frame.rst_stream)
        | (pkt.payload.value(I) isa frame.connection_close));
        # require ~conn_closed(src,scid);  # [6]

        # An initial packet with an unseen destination cid is a connection request.
        if ~conn_seen(dcid) {
            call client_initial_request(src,dst,pkt);
            conn_requested(src,dst,scid) := true;
        };
    
    };

    conn_seen(scid) := true;  # [1]

    # An ack-only packet must be in response to a non-ack-only packet

    if queued_non_ack(scid) {
	ack_credit(dcid) := ack_credit(dcid) + 1;
    } else {
	ack_credit(scid) := ack_credit(scid) - 1;
    };

    # If the packet contains a close frame, then set `pkt_has_close`

    var e := queued_level(scid);
    var pnum := decode_packet_number(src,scid,e,pkt.hdr_pkt_num);
    if queued_close(scid) {
        pkt_has_close(scid,e,pnum) := true;
    };

    # If the sender is in the draining state, this is the draining packet.

    if conn_draining(scid) {
        draining_pkt_sent(scid) := true
    };

    # The queued frames are deleted
    
    queued_frames(scid) := frame.arr.empty;
    queued_hello(scid) := false;
    queued_non_probing(scid) := false;
    queued_non_ack(scid) := false;
    queued_close(scid) := false;
    num_queued_frames(scid) := 0;
}



# TLS handshake protocol state
# ----------------------------

# - For aid C, `crypto_data(C,L)` represents the crypto handshake data
#   transmitted by TLS from C in encyption level L. This data may or
#   may not yet have been transmitted in any QUIC packet.
#
# - For aid C, the relation `crypto_data_presents(C,L)` represents the
#   set of byte positions that are present in the crypto handshake
#   data transmitted by TLS from C in encyption level L. A handshake
#   data byte may not be present, even if bytes in higher positions
#   are present (in other words, the handshake data may contain
#   "holes"). This allows the handshake data bytes to be generated out
#   of order, but processed in order.
#
# - For aid C, `crypto_data_end(C,L)` represents the length in bytes
#   of the crypto handshake data transmitted by TLS from C in
#   encyption level L. That is, it is the position of the highest
#   present byte plus one, or zero if there are no present bytes.
#
# - For aid C, `crypto_length(C,L)` indicates the length of the crypto
#   handshake data transmitted in QUIC frames from C at encyption
#   level L. The length is the least stream position greater than the
#   position of all bytes transmitted. Note this may be less than the
#   length of the crypto data, but may not be greater.
#
# - For aid C, `crypto_pos(C,L)` represents the read position of the
#   crypto data transmitted by C in encyption level L. This is the
#   number of bytes in the stream that have been read by TLS at the
#   peer.
#
# - For aid C, `crypto_handler_pos(C,L)` represents the position in the
#   crypto handshake data sent by C of any partial message at end, or
#   if there is no partial message, the end position.
#
# - For each aid C, `conn_enc_level` represents the current encryption
#   level of TLS at C.
#
# - The predicate `established_1rtt_keys(C)` holds if TLS has established
#   its 1rrt keys at aid C.
#
# - The predicate `established_handshake_keys(C)` holds if TLS has established
#   its handshake keys at aid C.

function crypto_data(C:cid,L:encryption_level) : stream_data
relation crypto_data_present(C:cid,L:encryption_level,P:stream_pos)
function crypto_data_end(C:cid,L:encryption_level) : stream_pos
function crypto_length(C:cid,L:encryption_level) : stream_pos
function crypto_pos(C:cid,L:encryption_level) : stream_pos
function crypto_handler_pos(C:cid,L:encryption_level) : stream_pos
function conn_enc_level(E:ip.endpoint,C:cid) : encryption_level
relation established_1rtt_keys(C:cid)
relation established_handshake_keys(C:cid)


# Initial state
# -------------

# The history variables are initialized as follows.  Initially, no
# connections have been seen and no packets have been sent or
# acknowledged.

after init {
    conn_seen(C) := false;
    last_pkt_num(C,L) := 0;
    conn_closed(C) := false;
    conn_draining(C) := false;
    draining_pkt_sent(C) := false;
    sent_pkt(C,L,N) := false;
    acked_pkt(C,L,N) := false;
    pkt_has_close(C,L,N) := false;
    max_acked(C,L) := 0;
    ack_credit(C) := 0;
    trans_params_set(C:cid) := false;
    stream_seen(C,S) := false;
    stream_length(C,S) := 0;
    max_stream_data_set(C,S) := false;
    max_data_set(C) := false;
    stream_finished(C,S) := false;
    stream_reset(C,S) := false;
    stream_app_pos(C,S) := 0;
    queued_hello(C) := false;
    queued_non_probing(C) := false;
    queued_non_ack(C) := false;
    queued_close(C) := false;
    conn_enc_level(E,C) := encryption_level.initial;
    established_1rtt_keys(C:cid) := false;
    established_handshake_keys(C:cid) := false;
    crypto_handler_pos(C,L) := 0;
    is_client(C) := false;
    conn_requested(S,D,C) := false;
    path_challenge_pending(C,D) := false;
    hi_non_probing(C) := 0;
    hi_non_probing_endpoint(C,E) := false;
    stream_app_data_finished(C,S) := false;

    cid_mapped(C) := false;
}

# Ghost events
# ------------
#
# A ghost event is an internal event of the system under test that may
# not be directly observable by the tester. These events may
# correspond to communication between an application and a protocol
# imlemenation, or an action within the application. In this case the
# ghost event typically represents in some way the semantics of a
# service being provided. Ghost evenst also sometimes correspond to
# non-deterministic events within the implementation of a service, for
# example the ordering of requests.
#
# During testing, inference of unobservable ghost events may be
# computationally intractable. In these cases, the system under test
# may need to be instrumented to record these events. In other cases,
# it may be feasible to infer the events from the observable
# communication. This is usually done by instrumenting the
# communication monitors with additional code the generates the ghost
# events. Incorrect inference of ghost events may result in a false
# alarm in testing.
#
#
# Open event
# ==========
#
# The first event in the life of a connection at a given is an `open_event`.
# At this point, the endpoint chooses its default transport parameters. Once
# the `open_event` has occurred, the security handshake can begin.
#
# Requirements:
#
# - The connection must not already be open at the endpoint
# - The transport parameters have not already been set
#

# before open_event(src:ip.endpoint, dst:ip.endpoint, pcid:cid, tp:trans_params_struct) {
#     require conn_open(src,pcid);
#     require ~trans_params_set(dst,pcid)
#     conn_open(src,pcid) := true;
#     trans_params_set(dst,pcid) := true;
#     trans_params(dst,pcid) := tp;
# }    

# Encryption level change

action set_encryption_level(src:ip.endpoint, scid:cid, e:encryption_level)

after set_encryption_level {
    conn_enc_level(src,scid) := e;
}

# TLS send event
# ==============
#
# This event corresponds to transmission of data between from a TLS
# endpoint to its peer on a given connection. In concept it occurs at
# the moment when the implmentation of TLS passes data to QUIC to be
# transmitted to the peer. This is a ghost event, since it is not
# visible on the wire. However, it can easily be inferred by examining
# the QUIC crypto frames.
#
# Requirements
#
# - The connection must be open [3].
# - The data must consist of a sequence of whole TLS records [1]
#
# Effects
#
# - The TLS data is appended to the crypto data [4].
#
# - The effect of each transmitted TLS record on the QUIC connection
#   state is defined by `handle_tls_record`, below [2]. A TLS
#   extension to client and server hello messages carries the
#   connection's initial transport parameters and is required.
#

before tls_send_event(src:ip.endpoint, dst:ip.endpoint, scid:cid, dcid:cid, data : stream_data,
                      pos : stream_pos, e:encryption_level) {
    var jdx := data.begin;
    var end := pos + data.end;
    if end > crypto_data(scid,e).end {
        crypto_data(scid,e) := crypto_data(scid,e).resize(end,0);
    };
    while jdx < data.end {
        var cpos := pos+jdx;
        var byte := data.value(jdx);
        require crypto_data_present(scid,e,cpos) -> crypto_data(scid,e).value(cpos) = byte;
        crypto_data_end(scid,e) := end;
	crypto_data(scid,e) := crypto_data(scid,e).set(cpos,byte);  # [4]
        crypto_data_present(scid,e,cpos) := true;
	jdx := jdx.next
    };
    crypto_data_end(scid,e) := crypto_data(scid,e).end;
    var max_present : stream_pos := 0;
    while max_present < crypto_data_end(scid,e) & crypto_data_present(scid,e,max_present) {
        max_present := max_present.next
    };
    # require conn_open(src,dcid);  # [3]
    var avail := crypto_data(scid,e).segment(crypto_handler_pos(scid,e),max_present);
    var res := tls.handshake_parser.deserialize(avail,0);
    var hs := res.value;
    call tls.handshake_data_event(src,dst,avail.segment(0,res.pos));
    crypto_handler_pos(scid,e) := crypto_handler_pos(scid,e) + res.pos;
    var idx := hs.begin;
    while idx < hs.end {
        var h := hs.value(idx);
        call tls.handshake_event(src,dst,h);
        call handle_tls_handshake(src,dst,scid,dcid,h);  #[2]
        idx := idx.next
    };
}

#
# TLS receive event
# =================
#
# This event corresponds to transfer of data from QUIC to the TLS
# implementation. 

action tls_recv_event(src:ip.endpoint, dst:ip.endpoint, scid:cid, dcid:cid, e:encryption_level, lo: stream_pos, hi : stream_pos)
    
around tls_recv_event {

    require cid_dst_to_src_set(dcid) & cid_dst_to_src(dcid) = scid;
    require lo < hi & lo = crypto_pos(dcid,e) & hi <= crypto_length(scid,e);
    #    require (data.end) + crypto_pos(pcid,0) <= crypto_length(pcid,0);
#    require 0 <= N & N < data.end -> data.value(N) = crypto_data(pcid,0).value(N + crypto_pos(pcid,0));
    ...
    
    crypto_pos(dcid,e) := hi;
    #    crypto_pos(pcid,0) := crypto_pos(pcid,0) + data.end 
}

#
# TLS keys established event
# ==========================
#
# This event occurs when TLS ata particular aid discovers the
# encryption and decryption keys for a particular encryption level
#

action tls_keys_established_event(scid:cid, e:encryption_level)

after tls_keys_established_event {
    call show_tls_keys_established_event(scid,e);
    if e = encryption_level.handshake {
        established_handshake_keys(scid) := true
    } else if e = encryption_level.other {
        established_1rtt_keys(scid) := true
    }
}




# ### Packet number decoding

# The packet number is decoded from the packet header fields as follows.

# If the connection is new, the field `hdr_pkt_num` gives the
# exact first packet number. Otherwise, it represents only a number
# of low order bits. The high-order bits must be inferred from the
# last packet number seen for this connection.

# For short format packets. the number of low order bits present
# in `hdr_pkt_num` depends on the `hdr_type` field of the packet,
# according to this table:
#
#   | hdr_type | bits |
#   |----------|------|
#   | 0x1d     | 32   |
#   | 0x1e     | 16   | 
#   | 0x1f     |  8   |
#
# For long format packets, the number of bits is always 32.  The
# decoded packet number is the nearest number to the last packet number seen
# whose whose low-order bits agree with `hdr_pkt_num`. Note this is ambiguous
# in the case that `hdr_pkt_num - last_pkt_num = 2^(n-1) mod 2^n` where `n`
# is the number of bits, since `last_pkt_num + 2^(n-1)` and `last_pkt_num - 2^(n-1)`
# both equal `hdr_pkt_num` modulo `2^n` and are equidistant from `last_pkt_num`.
# This case is forbidden.
#
# Requirements
#
# - The sent packet number must be no greater than `la + max/2` where
#   `la` is the greatest acknowledged packet number (or zero if there
#   have been no acks) and `max` is a largest number that can be
#   represented with the number of bits provided [1].
#
# Notes:
#
# - The IETF draft uses this langauge: "The sender MUST use a packet
#   number size able to represent more than twice as large a range
#   than the difference between the largest acknowledged packet and
#   packet number being sent." The meaning of "more than twice as
#   large a range" isn't clear, but here we take it to mean that
#   `2 * (pnum - la) ` is representable. It is also not clear how the
#   maximum packet number is computed if no acks have been received,
#   but we assume here that `la` is zero in this case.
#
#   TODO: this seems inconsistent with the following statement: "The
#   initial value for packet number MUST be selected randomly from a
#   range between 0 and 2^32 - 1025 (inclusive)." Possibly there is no
#   upper limit on the packet number if no acks have been received
#   yet, but this seems questionable.

action decode_packet_number(src:ip.endpoint,scid:cid,e:encryption_level,pnum:pkt_num) returns (pnum:pkt_num) = {

    var la := max_acked(scid,e);

    # This is the last number transmitted by the source on this connection.

    var last := last_pkt_num(scid,e);

    # TODO: for now, assume always 30-bit packet number format

    if true {
        var diff : pkt_num := bfe[0][29](pnum - last);
        pnum := last + diff;
        if diff >= 0x20000000 {
            pnum := pnum - 0x40000000
        };
        # require pnum <= la + 0x7ffffffe;
        # TEMPORARY: work around minquic bug
        require pnum <= last + 0x15;
    }
}

# TLS extensions are used in the client hello and server hello
# messages to carry the QUIC transport parameters, via special TLS
# extension type `quic_transport_parameters`. This type is define in
# the reference `quic_transport_parameters`. Here we define the
# protocol rules associated with `quic_transport_parameters`.
#
# The `handle_tls_handshake` rules apply to each `client_hello`,
# `server_hello` or `encrypted extensions` message, in order of
# occurrence in the crypto data.  The last parameter,
# `is_client_hello`, is true for a `client_hello` message (see below).
#
# A server hello establishes the connection between the server and the
# client cids [1]. We have to do it this way because there is no way
# looking at just the QUIC packet header and frame types to
# distinguish a client initial message from a server initial message.
#
# We also infer changes in encryption level from the handshake message
# types. In particular, any non-hello message moves us from the initial
# level to the handshake level. TODO: this might not be reliable if there
# are changes to TLS. It would be better to get an explicit signal from
# TLS that the level is changing. TODO: Does the QUIC-TLS specification
# say explicitly when the encryption level should change?
#

action handle_tls_handshake(src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid,hs:tls.handshake) = {

    if some(ch:tls.client_hello) hs *> ch {
        queued_hello(scid) := true;
        is_client(scid) := true;
        call handle_tls_extensions(src,dst,scid,ch.extensions,true);
    }
    else if some(sh:tls.server_hello) hs *> sh {
        queued_hello(scid) := true;
#        call map_cids(src,scid,dcid);    # [1]
#        call map_cids(dst,dcid,scid);
        call handle_tls_extensions(src,dst,scid,sh.extensions,false);
    }
    else if some(ee:tls.encrypted_extensions) hs *> ee {
        call handle_tls_extensions(src,dst,scid,ee.extensions,false);
    }
}

action map_cids(dcid:cid,scid:cid) = {
    cid_dst_to_src_set(dcid) := true;
    cid_dst_to_src(dcid) := scid
}

# An open connection event occurs on server src when it recieves a connection
# request from a client dst, with cid dcid. The server selects its own cid scid,
# and registers the peer relationship between the two cids.
#
# Requirements:
#
# - A connection must have been requested [1].
# - The two cids must not be previously associated to any peer [2]. 
# - Gives one ack credit to the server for the initial packet

action open_connection(src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid)

around open_connection {
    require conn_requested(dst,src,dcid);  # [1] 
    require ~cid_dst_to_src_set(dcid) & ~cid_dst_to_src_set(scid);  # [2]
    ...
    call map_cids(scid,dcid);
    call map_cids(dcid,scid);
    ack_credit(scid) := ack_credit(scid) + 1;
}

# Requirements:
#
# 1. Transport parameters must be declared in the client hello
#    and server hello message [1] and may be declared only once [2].
#
# The rules in `handle_client_transport_parameters` apply to each
# `quic_transport_parameters` extension instance in order of
# occurrence.
#

action handle_tls_extensions
    (src:ip.endpoint,
     dst:ip.endpoint,
     scid:cid,
     exts:vector[tls.extension],
     is_client_hello:bool) =
{

    # We process the extensions in a message in order.

    var idx := exts.begin;
    while idx < exts.end {
        var ext := exts.value(idx);
            
        # For every `quic_transport_parameters` extension...

        if some (tps:quic_transport_parameters) ext *> tps {
            call handle_client_transport_parameters(src,dst,scid,tps,is_client_hello);
#            require ~trans_params_set(scid);  # [2]
            trans_params_set(scid) := true;
            
        };
        idx := idx.next
    };
    # TEMPORARY: exempt server from sending transport parameters, since
    # minq doesn't implement this.
# TEMPORARY: skip this until Botan supports it
#    if is_client_hello {
#        require trans_params_set(scid);
#    }
}


# The rules in `handle_transport_parameter` apply to each
# `transport_parameter` instance a `quic_transport_parameters`
# extension, in order of occurrence.

# Requirements:
#
# - The endpoint must issue an `initial_max_stream_data` value [1].
# - The endpoint must issue an `initial_max_data` value [2].
# - The endpoint must issue an `idle_timeout` value [3].
# - A client must not issue an `stateless_reset_token` value [4].
#
# Note:
#
# - Setting a transport parameter requires that the parameter is not
#   previously set.

action handle_client_transport_parameters(src:ip.endpoint,dst:ip.endpoint,scid:cid,
                                          tps:quic_transport_parameters,
                                          is_client_hello : bool) =
{
    call client_transport_parameters_event(src,dst,scid,tps);
    var idx := tps.transport_parameters.begin;
    while idx < tps.transport_parameters.end {
        trans_params(scid) := tps.transport_parameters.value(idx).set(trans_params(scid));
        idx := idx.next
    };
    require initial_max_stream_data_bidi_local.is_set(trans_params(scid));  # [1]
    require initial_max_data.is_set(trans_params(scid));  # [2]
    require idle_timeout.is_set(trans_params(scid));  # [3]
    require initial_max_stream_data_bidi_remote.is_set(trans_params(scid));  # [1]
    require initial_max_stream_data_uni.is_set(trans_params(scid));  # [1]
    if is_client_hello {
        require ~stateless_reset_token.is_set(trans_params(scid));  # [4]
    }
}






action client_transport_parameters_event(src:ip.endpoint,dst:ip.endpoint,scid:cid,
                                         tps:quic_transport_parameters)

import client_transport_parameters_event

action show_enc_level(e:encryption_level)

import show_enc_level

import action show_offset_length(offset:stream_pos,length:stream_pos)

import action show_pstats(scid:cid,e:encryption_level,pnum:pkt_num)

import action show_tls_keys_established_event(scid:cid, e:encryption_level)
