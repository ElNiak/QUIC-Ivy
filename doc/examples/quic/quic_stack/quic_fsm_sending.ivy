#lang ivy1.7

include quic_types

# https://tools.ietf.org/html/draft-ietf-quic-transport-31#page-15

# Since we want to represent the sending FSM of the tested implementation,
# we will use these relations when WE receive frame infering the state
# of the opponant.

# - For each stream id S, `sending_ready(S)`
#   indicates that a stream has been create by the sender. 
# => not testable since we only receive its frame

relation sending_ready(S:stream_id)

# - For stream id S, `sending_send(S)` indicates that for
#   the stream id S, we received either a STREAM frame, either
#   a STREAM_DATA_BLOCKED or that a bidirectional stream is 
#   open
# => meaning =  we received STREAM or STREAM_DATA_BLOCKED frame

relation sending_send(S:stream_id)

# - For stream id S, `sending_dataSent(S)` indicates that
#   the stream on stream id S is finished by sender (that is, a
#   FIN frame has been sent). (stream_finished)
# => meaning =  we received STREAM+FIN bit
#,P:pkt_num

relation sending_dataSent(S:stream_id)

# - For stream id S, `sending_dataRecvd(S)` indicates that
#   the stream id S is finished and that all the ack has been received
# => meaning = [no retransmission of the STREAM or STREAM_DATA_BLOCKED frames
#              we represent retransmission by receiving twice packet with same 
#              pkt_num => we should know the pkt_num of the frames],
#              we send ack for the packet number

relation sending_dataRecvd(S:stream_id)

# - For each  stream id S, `sending_resetSent(S)` indicates that
#   the stream transmitted by sender on stream id S is reset (that is, a
#   RESET_STREAM frame has been sent). (stream_reset)
# => meaning = we received RESET_STREAM
#,P:pkt_num

relation sending_resetSent(S:stream_id)

# - For stream id S, `sending_resetRecvd(S)` indicates that
#   the stream id S is reset and that the RST ack has been received
# => meaning = [no retransmission of RST frame or] we send ack for 
#              corresponding packet/frame = liveness

relation sending_resetRecvd(S:stream_id)

function lastest_stream_id_sender(P:pkt_num) : stream_id
function lastest_pkt_num_sender : pkt_num

# Initial state
# -------------

after init {
    sending_ready(S)      := true;
    sending_send(S)       := false;
    sending_dataSent(S)   := false;
    sending_dataRecvd(S)  := false;
    sending_resetSent(S)  := false;
    sending_resetRecvd(S) := false;
    lastest_stream_id_sender(P) := 0;
    lastest_pkt_num_sender      := 0;
}

action handle_sending_send(id:stream_id) = {
    # possible source state/transition
    require sending_ready(id);
    # set of non allowed state (useless ?) ~sending_send(id) &
    require  ~sending_dataSent(id) & ~sending_dataRecvd(id) & ~sending_resetSent(id) & ~sending_resetRecvd(id);
    sending_ready(id) := false;
    sending_send(id)  := true;
    call show_fsm_sending_send_event(lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
    call show_sending_fsm_event(sending_ready(id), sending_send(id), sending_dataSent(id), sending_dataRecvd(id), sending_resetSent(id), sending_resetRecvd(id), lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
}

action handle_sending_dataSent(id:stream_id,seq:pkt_num) = {
    # possible source state/transition
    require sending_send(id);
    # set of non allowed state  ~sending_dataSent(id) &
    require  ~sending_dataRecvd(id) & ~sending_resetSent(id) & ~sending_resetRecvd(id);
    sending_send(id) := false;
    sending_dataSent(id) := true;
    lastest_stream_id_sender(seq) := id;
    lastest_pkt_num_sender := seq;
    call show_fsm_sending_dataSent_event(lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
    call show_sending_fsm_event(sending_ready(id), sending_send(id), sending_dataSent(id), sending_dataRecvd(id), sending_resetSent(id), sending_resetRecvd(id), lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
}

action handle_sending_dataRecvd(id:stream_id) = {
    # possible source state/transition
    require sending_dataSent(id);
    # set of non allowed state  ~sending_dataRecvd(id) &
    require  ~sending_send(id) & ~sending_resetSent(id) & ~sending_resetRecvd(id);
    sending_dataSent(id)  := false;
    sending_dataRecvd(id) := true;
    call show_fsm_sending_dataRecvd_event(lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
    call show_sending_fsm_event(sending_ready(id), sending_send(id), sending_dataSent(id), sending_dataRecvd(id), sending_resetSent(id), sending_resetRecvd(id), lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
}

action handle_sending_resetSent(id:stream_id,seq:pkt_num) = {
    # possible source state/transition
    require sending_dataSent(id) | sending_send(id) | sending_ready(id);
    # set of non allowed state & ~sending_resetSent(id)
    require  ~sending_dataRecvd(id) & ~sending_resetRecvd(id);
    sending_ready(id) := false;
    sending_dataSent(id) := false;
    sending_send(id) := false;
    sending_resetSent(id) :=  true;
    lastest_stream_id_sender(seq) := id;
    lastest_pkt_num_sender := seq;
    call show_fsm_sending_resetSent_event(lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
    call show_sending_fsm_event(sending_ready(id), sending_send(id), sending_dataSent(id), sending_dataRecvd(id), sending_resetSent(id), sending_resetRecvd(id), lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
}

action handle_sending_resetRecvd(id:stream_id) = {
    # possible source state/transition
    require sending_resetSent(id);
    # set of non allowed state & ~sending_resetRecvd(id)
     require  ~sending_send(id) & ~sending_dataSent(id);
    sending_resetSent(id) := false;
    sending_ready(id) := true;
    sending_resetRecvd(id) := true;
    call show_fsm_sending_resetRecvd_event(lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
    call show_sending_fsm_event(sending_ready(id), sending_send(id), sending_dataSent(id), sending_dataRecvd(id), sending_resetSent(id), sending_resetRecvd(id), lastest_stream_id_sender(lastest_pkt_num_sender),lastest_pkt_num_sender);
}

# check if same stream_id twice, add not _generating when calling these

# ====================================================================
# Auxilary functions
#=====================================================================

action handle_sending_ack(largest_acked:pkt_num) = {
    var id := get_streamid_from_ack_sender(largest_acked);
    if sending_resetSent(id) { 
        call handle_sending_resetRecvd(id);
    } else if sending_dataSent(id) {
        call handle_sending_dataRecvd(id);
    };
}

# Here we assume that the last packet num define the largest_ack
action get_streamid_from_ack_sender(largest_acked:pkt_num)  
returns (id:stream_id) = {
    if lastest_pkt_num_sender <= largest_acked {
        id := lastest_stream_id_sender(lastest_pkt_num_sender);
    } else {
        id := lastest_stream_id_sender(largest_acked);
    };
}

import action show_sending_fsm_event(sending_ready:bool,sending_send:bool,
                                     sending_dataSent:bool,sending_dataRecvd:bool,
                                     sending_resetSent:bool,sending_resetRecvd:bool,
                                     lastest_stream_id_sender:stream_id,lastest_pkt_num_sender:pkt_num)

import action show_fsm_sending_ready_event(lastest_stream_id_sender:stream_id,lastest_pkt_num_sender:pkt_num)

import action show_fsm_sending_send_event(lastest_stream_id_sender:stream_id,lastest_pkt_num_sender:pkt_num)

import action show_fsm_sending_dataSent_event(lastest_stream_id_sender:stream_id,lastest_pkt_num_sender:pkt_num)

import action show_fsm_sending_dataRecvd_event(lastest_stream_id_sender:stream_id,lastest_pkt_num_sender:pkt_num)

import action show_fsm_sending_resetSent_event(lastest_stream_id_sender:stream_id,lastest_pkt_num_sender:pkt_num)

import action show_fsm_sending_resetRecvd_event(lastest_stream_id_sender:stream_id,lastest_pkt_num_sender:pkt_num)