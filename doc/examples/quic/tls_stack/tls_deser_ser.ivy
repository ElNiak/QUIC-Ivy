#lang ivy1.7

# Deserializer for TLS records

include tls_record

object tls_deser = {}
object tls_ser = {}
object tls_ser_server = {}

<<< member

    class `tls_deser`;
    class `tls_ser`;
    class `tls_ser_server`;

>>>

<<< impl

    //https://tools.ietf.org/html/draft-thomson-quic-bit-grease-00
    //https://tools.ietf.org/id/draft-huitema-quic-ts-03.html
    
    typedef struct tls_name_struct {
        const char *name;
        int value;
    } *tls_name_struct_ptr;

    struct tls_name_map : hash_space::hash_map<std::string,int> {};

    std::string quic_params[17] = { 
        "quic_transport_parameters",
        "initial_max_stream_data_bidi_local",
        "initial_max_data",
        "initial_max_stream_id_bidi",
        "max_idle_timeout",
        "preferred_address",
        "max_packet_size",
        "stateless_reset_token",
        "ack_delay_exponent",
        "initial_max_stream_id_uni",
        "disable_migration",
        "active_connection_id_limit",
        "initial_max_stream_data_bidi_remote",
        "initial_max_stream_data_uni",
        "max_ack_delay",
        "initial_source_connection_id",
        "loss_bits"
    };

    struct tls_name_struct tls_field_length_bytes[32] = {
        {"fragment",2},
        {"content",2},
        {"tls.client_hello",3},
        {"tls.server_hello",3},
        {"tls.encrypted_extensions",3},
        {"unknown_message_bytes",3},
        {"session_id",1},
        {"cipher_suites",2},
        {"compression_methods",1},
        {"extensions",2},
        {"quic_transport_parameters",2},
        //{"transport_parameters",2}, // Parameter length field
        {"initial_max_stream_data_bidi_local",1},
        {"initial_max_data",1},
        {"initial_max_stream_id_bidi",1},
        {"max_idle_timeout",1},
        {"preferred_address",1},
        {"max_packet_size",1},
        {"stateless_reset_token",1},
        {"ack_delay_exponent",1},
        {"initial_max_stream_id_uni",1},
        {"disable_active_migration ",1},
        {"active_connection_id_limit",1},
        {"initial_max_stream_data_bidi_remote",1},
        {"initial_max_stream_data_uni",1},
        {"max_ack_delay",1},
        {"initial_source_connection_id",1},
        {"loss_bits",2},     //for picoquic TODO test
        {"min_ack_delay",11},
        {"grease_quic_bit",0}, //for picoquic
        {"enable_time_stamp",1}, //for picoquic TODO test
        {"unknown_transport_parameter",2},
        {0,0}
    };
    tls_name_map tls_field_length_bytes_map;

    struct tls_name_struct tls_field_bytes[20] = {
        {"version",2},
        {"client_version",2}, //0x0303 = 2 bytes
        {"server_version",2},
        {"etype",2},
        {"mtype",1},
        {"gmt_unix_time",4},
        {"cipher_suites",2},
        {"the_cipher_suite",2},
        {"compression_methods",1},
        {"the_compression_method",1},
        {"session_id",1},
        {"content",1},
        {"initial_version",4},
        {"stream_pos_32",-1},
        {"stream_id_16",-1},
        {"seconds_16",-1},
        {"stream_pos_16",-1},
        {"exponent_8",-1},
        {"data_8",1},
        {0,0}
    };
    tls_name_map tls_field_bytes_map;

    //TODO check old version
    struct tls_name_struct tls_tags[30] = {
        {"tls.handshake_record",22},
        {"tls.application_data_record",23},
        {"tls.change_cipher_spec",20},
        {"tls.client_hello",1},
        {"tls.server_hello",2},
        {"tls.encrypted_extensions",0x08},
        {"tls.unknown_message",-1},
        {"tls.unknown_extension",-1},
        {"quic_transport_parameters",0xffa5},
        {"initial_max_stream_data_bidi_local",0x05},
        {"initial_max_data",0x04},
        {"initial_max_stream_id_bidi",0x08},
        {"max_idle_timeout",0x01},
        {"preferred_address",0xd},
        {"max_packet_size",0x03},
        {"stateless_reset_token",0x02},
        {"ack_delay_exponent",0xa},
        {"initial_max_stream_id_uni",0x09},
        {"disable_active_migration ",0xc},
        {"active_connection_id_limit",0xe},
        {"initial_max_stream_data_bidi_remote",0x06},
        {"initial_max_stream_data_uni",0x07},
        {"max_ack_delay",0xb}, 
        {"initial_source_connection_id",0x0f},
        {"loss_bits",0x1057}, //for picoquic
        {"min_ack_delay",0xC0}, //0xff02de1a TODO
        {"grease_quic_bit",0x2ab2}, //for picoquic
        {"enable_time_stamp",0x7158}, //for picoquic 0x7158 800
        {"unknown_transport_parameter",-2},
       {0,0}
    };
    tls_name_map tls_tags_map;

    struct tls_name_struct tls_tag_bytes[23] = {
        {"tls.unknown_extension",2},
        {"quic_transport_parameters",2},
        {"initial_max_stream_data_bidi_local",1},
        {"initial_max_data",1},
        {"initial_max_stream_id_bidi",1},
        {"max_idle_timeout",1},
        {"preferred_address",1},
        {"max_packet_size",1},
        {"stateless_reset_token",1},
        {"ack_delay_exponent",1},
        {"initial_max_stream_id_uni",1},
        {"disable_migration",1},
        {"active_connection_id_limit",1},
        {"initial_max_stream_data_bidi_remote",1},
        {"initial_max_stream_data_uni",1},
        {"max_ack_delay",1},
        {"initial_source_connection_id",1},
        {"loss_bits",2}, //for picoquic 
        {"min_ack_delay",8},
        {"grease_quic_bit",2}, //for picoquic
        {"enable_time_stamp",2}, //for picoquic 
        {"unknown_transport_parameter",2},
        {0,0}
    };
    tls_name_map tls_tag_bytes_map;

    void tls_make_name_map(tls_name_struct *vals, tls_name_map &map) {
        while (vals->name) {
            map[vals->name] = vals->value;
            vals++;
        }
    }

    class `tls_deser` : public ivy_binary_deser {
        int field_bytes;
        std::vector<unsigned> fence;
        int in_encrypted_extensions;

    public:

        tls_deser(const std::vector<char> &inp) : ivy_binary_deser(inp) {
            field_bytes = 2;
            in_encrypted_extensions = 0;
        }

        virtual bool more(unsigned bytes) {
            if (fence.size() > 0 && pos + bytes > fence.back())
                return false;
            return ivy_binary_deser::more(bytes);
        }
    
        virtual void open_field(const std::string &name) {
            std::cout << "open_field1: name : " << name << std::endl;  
            if (name == "random_bytes") { //28 bytes tls1.2, 32bytes tls1.3
                fence.push_back(pos+28);
                field_bytes = 1;
            }
            else if (name == "versions") {
                field_bytes = 4;
                long long bytes = 0;
                if (in_encrypted_extensions) {
                    getn(bytes,1);
                }
                fence.push_back(pos+bytes);
            }
            else if (tls_field_length_bytes_map.find(name) != tls_field_length_bytes_map.end()) {
                int length_field_bytes = tls_field_length_bytes_map[name];
                long long bytes;
                getn(bytes,length_field_bytes);
                fence.push_back(pos+bytes);
            } //TODO change transport parameter var name (not ..._8)
            else if (fence.size() > 0) {
                fence.push_back(fence.back());
            } 
            if (tls_field_bytes_map.find(name) != tls_field_bytes_map.end()) {
                field_bytes = tls_field_bytes_map[name];
            }
            if (name == "tls.encrypted_extensions") {
                in_encrypted_extensions = fence.size();
            }
	    std::cout << std::endl; 
        }

        virtual void close_field() {
            if (fence.size() == in_encrypted_extensions)
                in_encrypted_extensions = 0;
            if (fence.size() > 0)
                fence.pop_back();
        }

        // TODO error
        virtual int open_tag(const std::vector<std::string> &tags) {
            int bytes = 1;
            if (tls_tag_bytes_map.find(tags[0]) != tls_tag_bytes_map.end())   {
                std::cout << tags[0] << std::endl; 
                std::cout << tls_tag_bytes_map[tags[0]] << std::endl;  
                bytes = tls_tag_bytes_map[tags[0]];
            }
            long long tag;
        
            //std::cout << "tags" << tags << std::endl;
            std::cout << "bytes" << bytes << std::endl;  
            getn(tag,bytes);


	    u_int tag_int = (u_int) tag;
	    int first = (tag_int >> 6) & ((1 << 2) -1);
	    //int first =  tag_int & ((1 << 0) -1);
 	    if(first == 0)
		first = 1;
	    else if(first == 1)
		first = 2;
            else if(first == 2)
		first = 4;
	    else if(first == 3)
		first = 8;
	    std::cout <<  "first size: " <<  first << std::endl; 
            //get_var_int(tag);
            std::cout << tag << std::endl;  
            
            //std::cout << "tls_desert 1" << std::endl;  
            for (int i = 0; i < tags.size(); i++) {
                if (tag == tls_tags_map[tags[i]]) {
                   open_field(tags[i]);
                   std::cout << "tls_desert  << " << tags[i] << std::endl;  
                   //std::cout << std::endl;  
                   return i;
                }
            }
            for (int i = 0; i < tags.size(); i++) {
                if (-1 == tls_tags_map[tags[i]]) {
                    pos -= bytes; // leave the unknown tag to parse again
                    open_field(tags[i]);
                    std::cout << tags[i] << std::endl;  
                    //std::cout << std::endl;  
                    return i;
                }
            }
            for (int i = 0; i < tags.size(); i++) {
                if (-2 == tls_tags_map[tags[i]]) {
                    pos -= bytes; // leave the unknown tag to parse again
		    long long tag_unknown;
		    long long size;
		    
		    getn(tag_unknown,2);
		    getn(size,3);
		    long long tag_concat = tag_unknown-16384;
                    if(tag_concat % 31 == 27)
			std::cout <<  "found " << std::endl;  
		    pos -= bytes; 
		    pos -= bytes; 
		    std::cout <<  "tag 1 " << tag << std::endl; 
		    std::cout <<  "tag 2 " << tag_unknown << std::endl; 
		    std::cout <<  "tag_concat " << tag_concat << std::endl; 
		    while(size > 3)
		    	size = size % 256;
		    std::cout <<  "size " << size << std::endl; 
		    if(size == 0)
			size = 1;
		    else if(size == 1)
			size = 2;
		    else if(size == 2)
			size = 4;
		    else if(size == 3)
			size = 8;
		    long long size_off = size;
		    pos -= size_off; 
   		    std::cout <<  "size " << size << std::endl; 
                    //bytes = 2;
	            tls_field_length_bytes_map[tags[i]] = size;
		    std::cout <<  "tls_field_length_bytes_map[tags[i]] " << tls_field_length_bytes_map[tags[i]] << std::endl; 
                    open_field(tags[i]);
                    std::cout <<  "tags_i[2] " << tags[i] << std::endl;  
                    //std::cout << std::endl;  
                    return i;
                }
            }
            std::cout << "error tls_desert 1" << std::endl;  
            throw deser_err();
        }

        virtual void close_tag() {
            close_field();
        }

        virtual void get(long long &res) {
            if (field_bytes == -1) get_var_int(res);
            else getn(res,field_bytes);
        }

        void get_var_int(long long &res) {
            static int lens[4] = {0,1,3,7};
            long long lobyte;
            ivy_binary_deser::getn(lobyte,1);
            int bytes = lens[(lobyte & 0xc0) >> 6];
            ivy_binary_deser::getn(res,bytes);
            res |= (lobyte & 0x3f) << (bytes << 3);
        }

        virtual bool open_list_elem() {
            if (fence.size() == 0) {  // tricky: see if input contains a full message
                if (!more(4)) {
                    return false;
                }
                unsigned len = (inp[pos+1] << 16) + (inp[pos+2] << 8) + inp[pos];
                return inp.size() >= pos + len + 4;
            }
            return more(1);
        }
        void close_list_elem() {}

        void open_list() {}
        void close_list() {}

        ~tls_deser(){}
    };

    struct `tls_ser` : public ivy_binary_ser {

        int field_bytes;
        std::vector<unsigned> field_start;
        std::vector<unsigned> field_length_bytes;
        int in_encrypted_extensions;

        tls_ser() {
            in_encrypted_extensions = 0;
        }

        /** 
          * Allocate memory for each transport parameters
          */
        virtual void open_field(const std::string &name) {
            int flb = 0;
            std::cout << "open_field2: name : " << name << std::endl;  
            //if(name != "transport_parameters") { //TODO ugly see how to
                if (name == "random_bytes") {
                    field_bytes = 1;
                }
                else if (name == "versions") {
                    field_bytes = 4;
                    if (in_encrypted_extensions) {
                        flb = 1;
                        res.resize(res.size() + flb);
                    }
                }
                else if (tls_field_length_bytes_map.find(name) != tls_field_length_bytes_map.end()) {
                    flb = tls_field_length_bytes_map[name];
                    res.resize(res.size() + flb);
                }

                field_start.push_back(res.size());
                field_length_bytes.push_back(flb);
                if (tls_field_bytes_map.find(name) != tls_field_bytes_map.end()) {
                    field_bytes = tls_field_bytes_map[name];
                }
                if (name == "tls.encrypted_extensions") {
                    in_encrypted_extensions = field_start.size();
                }
            //}
            std::cout << "open_field2: res.size() : " << res.size() << std::endl;
        }
        //TODO [xx]
        virtual void close_field() {
            if (field_start.size() == in_encrypted_extensions)
                in_encrypted_extensions = 0;
            // tricky -- go back and fill in the length bytes after the field is serialized
            int start = field_start.back();
            int end = res.size();
            int flb = field_length_bytes.back();
            std::vector<char> temp;
            temp.swap(res);
            int len = end-start;
            setn(len,flb);
            temp.swap(res); //[xx] remove
            std::copy(temp.begin(),temp.end(),res.begin()+start-flb); // [xx] remove
            field_start.pop_back();
            field_length_bytes.pop_back();
        }

        virtual void open_tag(int ivy_tag, const std::string &name) {
            int bytes = 1;
            if (tls_tag_bytes_map.find(name) != tls_tag_bytes_map.end())
                bytes = tls_tag_bytes_map[name];
            long long tag = tls_tags_map[name];
            if (tag !=-1) 
                setn(tag,bytes); // var int ?
            open_field(name);
        }

        virtual void close_tag() {
            close_field();
        }

        void set(long long inp) {
            if (field_bytes == -1) set_var_int(inp);
            else setn(inp,field_bytes);
        }

        void set_var_int(long long res) {
            long long val = res & 0x3fffffffffffffff;
            int bytecode = res <= 0x3f ? 0 : res <= 0x3fff ? 1 : res <= 0x3fffffff ? 2 : 3;
            int bytes = 1 << bytecode;
            val |= bytecode << ((bytes << 3) - 2);
            setn(val,bytes);
        }

        void open_list(int len) {
        }
    };

    struct `tls_ser_server` : public tls_ser {
        // This version of the serializer uses the server format. The only difference is
        // that the QUIC_extension structure has an extra field "versions".

        tls_ser_server() {
          in_encrypted_extensions = -1; 
        }
    
    };
>>>

<<< init
    
    tls_make_name_map(tls_field_length_bytes,tls_field_length_bytes_map);
    tls_make_name_map(tls_field_bytes,tls_field_bytes_map);
    tls_make_name_map(tls_tags,tls_tags_map);
    tls_make_name_map(tls_tag_bytes,tls_tag_bytes_map);


>>>
