#lang ivy1.7

# ---
# layout: page
# title: QUIC connection protocol
# ---

# This document describes the wire specification of QUIC.  It is based
# on the following IETF drafts:
#
# 1.[QUIC: A UDP-Based Multiplexed and Secure Transport
# draft-ietf-quic-transport-14](https://tools.ietf.org/html/draft-ietf-quic-transport-14).
#
# 2. [Using Transport Layer Security (TLS) to Secure QUIC
# draft-ietf-quic-tls-14](https://tools.ietf.org/html/draft-ietf-quic-tls-14).
#
# The protocol is modeled as a stack of layers. Each layer
# is associated with one or more event types. The highest-level
# events in this stack correspond to the sending and receiving of
# application data, while the lowest-level events correspond
# to UDP datagrams. The layers in the stack are, from top to bottom:
#
# - The application
# - The TLS handshake protocol
# - The QUIC frame protocol
# - The QUIC packet protocol
# - QUIC packet protection
# - UDP
#
# References
# ==========

# Protocol state
# ==============

# This section desceibes the history variables that track the state of
# the various protocol layers. Some of these variables are sharded between
# protocol layers, so that the allowed interleavings of events at different
# layers can be specified.
#


include quic_types
include quic_frame
include quic_packet
include tls_protocol
include quic_transport_parameters



# Ghost events
# ------------
#
# A ghost event is an internal event of the system under test that may
# not be directly observable by the tester. These events may
# correspond to communication between an application and a protocol
# imlemenation, or an action within the application. In this case the
# ghost event typically represents in some way the semantics of a
# service being provided. Ghost evenst also sometimes correspond to
# non-deterministic events within the implementation of a service, for
# example the ordering of requests.
#
# During testing, inference of unobservable ghost events may be
# computationally intractable. In these cases, the system under test
# may need to be instrumented to record these events. In other cases,
# it may be feasible to infer the events from the observable
# communication. This is usually done by instrumenting the
# communication monitors with additional code the generates the ghost
# events. Incorrect inference of ghost events may result in a false
# alarm in testing.
#
#
# Open event
# ==========
#
# The first event in the life of a connection at a given is an `open_event`.
# At this point, the endpoint chooses its default transport parameters. Once
# the `open_event` has occurred, the security handshake can begin.
#
# Requirements:
#
# - The connection must not already be open at the endpoint
# - The transport parameters have not already been set
#

# before open_event(src:ip.endpoint, dst:ip.endpoint, pcid:cid, tp:trans_params_struct) {
#     require conn_open(src,pcid);
#     require ~trans_params_set(dst,pcid)
#     conn_open(src,pcid) := true;
#     trans_params_set(dst,pcid) := true;
#     trans_params(dst,pcid) := tp;
# }    


# ### Packet number decoding

# The packet number is decoded from the packet header fields as follows.

# If the connection is new, the field `hdr_pkt_num` gives the
# exact first packet number. Otherwise, it represents only a number
# of low order bits. The high-order bits must be inferred from the
# last packet number seen for this connection.

# For short format packets. the number of low order bits present
# in `hdr_pkt_num` depends on the `hdr_type` field of the packet,
# according to this table:
#
#   | hdr_type | bits |
#   |----------|------|
#   | 0x1d     | 32   |
#   | 0x1e     | 16   | 
#   | 0x1f     |  8   |
#
# For long format packets, the number of bits is always 32.  The
# decoded packet number is the nearest number to the last packet number seen
# whose whose low-order bits agree with `hdr_pkt_num`. Note this is ambiguous
# in the case that `hdr_pkt_num - last_pkt_num = 2^(n-1) mod 2^n` where `n`
# is the number of bits, since `last_pkt_num + 2^(n-1)` and `last_pkt_num - 2^(n-1)`
# both equal `hdr_pkt_num` modulo `2^n` and are equidistant from `last_pkt_num`.
# This case is forbidden.
#
# Requirements
#
# - The sent packet number must be no greater than `la + max/2` where
#   `la` is the greatest acknowledged packet number (or zero if there
#   have been no acks) and `max` is a largest number that can be
#   represented with the number of bits provided [1].
#
# Notes:
#
# - The IETF draft uses this langauge: "The sender MUST use a packet
#   number size able to represent more than twice as large a range
#   than the difference between the largest acknowledged packet and
#   packet number being sent." The meaning of "more than twice as
#   large a range" isn't clear, but here we take it to mean that
#   `2 * (pnum - la) ` is representable. It is also not clear how the
#   maximum packet number is computed if no acks have been received,
#   but we assume here that `la` is zero in this case.
#
#   TODO: this seems inconsistent with the following statement: "The
#   initial value for packet number MUST be selected randomly from a
#   range between 0 and 2^32 - 1025 (inclusive)." Possibly there is no
#   upper limit on the packet number if no acks have been received
#   yet, but this seems questionable.

# action decode_packet_number(src:ip.endpoint,scid:cid,e:encryption_level,pnum:pkt_num) returns (pnum:pkt_num) = {

#     var la := max_acked(scid,e);

    # This is the last number transmitted by the source on this connection.

#     var last := last_pkt_num(scid,e);

    # TODO: for now, assume always 30-bit packet number format

#     if true {
#         var diff : pkt_num := bfe[0][29](pnum - last);
#         pnum := last + diff;
#         if diff >= 0x20000000 {
#             pnum := pnum - 0x40000000
#         };
        # require pnum <= la + 0x7ffffffe;
        # TEMPORARY: work around minquic bug
#         require pnum <= last + 0x15;
#     }
# }


# An open connection event occurs on server src when it recieves a connection
# request from a client dst, with cid dcid. The server selects its own cid scid,
# and registers the peer relationship between the two cids.
#
# Requirements:
#
# - A connection must have been requested [1].
# - The two cids must not be previously associated to any peer [2]. 
# - Gives one ack credit to the server for the initial packet

# action open_connection(src:ip.endpoint,dst:ip.endpoint,scid:cid,dcid:cid)

# around open_connection {
#     require conn_requested(dst,src,dcid);  # [1] 
#     require ~cid_dst_to_src_set(dcid) & ~cid_dst_to_src_set(scid);  # [2]
#     ...
#     call map_cids(scid,dcid);
#     call map_cids(dcid,scid);
#     ack_credit(scid) := ack_credit(scid) + 1;
# }
