#lang ivy1.7

# https://github.com/h2o/picotls/blob/master/t/picotls.c

# This is an implementation of the generic TLS interface based on the picotls library.
# The parameters are:
#
#     cid : the type of connection ids
#     index : an unbounded sequence type
#     bytes : a type of byte arrays indexed by `index`
#     extens : a type of lists of extensions
#     lower : the lower interface
#     upper : the upper interface
#

module tls_gnutls(cid,index,bytes,extens,hextens,exten_ser,lower,upper) = {

    # Link the gnutls library

    attribute libspec = "picotls-core,picotls-minicrypto,picotls-openssl,ssl,crypto,dl,picotls.lib,libcrypto.lib,libssl.lib,cifra.lib,bcrypt.lib"
    

    # These empty objects are used to hold C++ values.

    object cb = {}          # struct holding the callbacks
    object cid_map = {}     # map from cid's to connections
    
    # This code goes in the C++ header file, ahead of the ivy object declaration.
    # Here, we put declarations (perhaps forward) of any auxiliary classes we need).
    # We need to be careful that the names of these don't clash with other modules.
    # However, duplicates are removed, so we don't have to worry about multiple instances
    # of this module clashing.

<<< header

    extern "C" {
    #ifdef _WIN32
    #include "picotls/wincompat.h"
    #endif
    #include "picotls.h"
    //#include "picotls.c"
    #include "picotls/openssl.h"
    #include "picotls/minicrypto.h"
    //#include <fmt/core.h>
    }

    #include <openssl/pem.h>

    // TODO: put any forward class definitions here

    class tls_callbacks;
    class picotls_connection;


>>>

# This code goes in the C++ implementation file. Here, we put implementations of
# the classes declared in the header, and auxiliary functions. 

<<< impl


    // This structure holds all the callbacks. These are functions
    // that are called synchronously.

    struct tls_callbacks {
        %`lower.send` ls;
        %`upper.recv` ur;
        %`upper.alert` ua;
        %`upper.keys_established` use;
    tls_callbacks(
        const %`lower.send` ls,
        const %`upper.recv` ur,
        const %`upper.alert` ua,
        const %`upper.keys_established` use
    )
    : ls(ls), ur(ur), ua(ua), use(use) {}
    };

    bool is_rtt = false;

    /* Per epoch crypto context. There are four such contexts:
     * 0: Initial context, with encryption based on a version dependent key,
     * 1: 0-RTT context
     * 2: Handshake context
     * 3: Application data
     */
    struct quic_crypto_context_t {
        void* aead_encrypt;
        void* aead_decrypt;
        void* pn_enc; /* Used for PN encryption */
        void* pn_dec; /* Used for PN decryption */
        quic_crypto_context_t() {
           aead_encrypt = aead_decrypt = pn_enc = pn_dec = 0;
        }
    };
    
    // Structure to hold state of a tls session

    struct picotls_connection {
        `cid` id;
        ptls_t *gs;
        ptls_context_t *cctx;
        tls_callbacks cb;
        ptls_handshake_properties_t *hsp;
        std::vector<char> input;
        int handshake_status;
        std::vector<quic_crypto_context_t> crypto_context;
        bool is_server;
        uint8_t* session_ticket;

        st_ptls_buffer_t message;

        picotls_connection(`cid` id, ptls_t *gs, ptls_context_t *cctx , tls_callbacks cb,
            ptls_handshake_properties_t *hsp, bool is_server)
            : id(id),gs(gs),cctx(cctx),cb(cb),hsp(hsp),is_server(is_server) {
            handshake_status = 0;
            session_ticket = NULL;
            crypto_context.resize(4);
        }
    };

    typedef struct st_stored_ticket_t {
        struct st_stored_ticket_t* next_ticket;
        char* sni;
        char* alpn;
        uint8_t* ip_addr;
        //uint64_t tp_0rtt[PICOQUIC_NB_TP_0RTT];
        uint8_t* ticket;
        uint64_t time_valid_until;
        uint16_t ticket_length;
        unsigned int was_used : 1;
    } stored_ticket_t;

    int tls_collect_extensions_cb(ptls_t* tls, struct st_ptls_handshake_properties_t* properties, uint16_t type)
    {
        return type & 0xff00 == 0xff00;
    }

    int tls_collected_extensions_cb(ptls_t* tls, ptls_handshake_properties_t* properties,
    ptls_raw_extension_t* slots)
    {
        // TODO: do something with incoming extensions
        return 0;
    }

    // These are some parameters defined byt the QUIC-TLS standard. They
    // don't really belong here, but then again, QUIC is currently the only
    // existing client of this TLS interface.

    #define QUIC_LABEL_QUIC_BASE "tls13 quic "
    #define QUIC_LABEL_PN "pn"
    #define QUIC_LABEL_INITIAL_CLIENT "client in"
    #define QUIC_LABEL_INITIAL_SERVER "server in"

    #define QUIC_LABEL_RETRY1 "quic key"
    #define QUIC_LABEL_RETRY2 "quic iv"

    #define PTLS_HELLO_RANDOM_SIZE 32

    #define PTLS_HANDSHAKE_HEADER_SIZE 4


    //SSL: ptls_get_client_random(), quic_update_traffic_key_callback
    // The following mess is to get the traffic keys from picotls

    void *aead_from_secret(ptls_cipher_suite_t * cipher, int is_enc, const void *secret)
    {
        return ptls_aead_new(cipher->aead, cipher->hash, is_enc, secret, QUIC_LABEL_QUIC_BASE);
    }

    void *pn_enc_from_secret(ptls_cipher_suite_t * cipher, int is_enc, const void *secret)
    {
        uint8_t key[PTLS_MAX_SECRET_SIZE];

        ptls_hkdf_expand_label(cipher->hash, key, 
                               cipher->aead->ctr_cipher->key_size,
                               ptls_iovec_init(secret, cipher->hash->digest_size), 
                               "quic hp",
                               ptls_iovec_init(NULL, 0),
                               NULL);

        return ptls_cipher_new(cipher->aead->ctr_cipher, is_enc, key);
    }

    struct st_ptls_key_schedule_t {
        unsigned generation; /* early secret (1), hanshake secret (2), master secret (3) */
        const char *hkdf_label_prefix;
        uint8_t secret[PTLS_MAX_DIGEST_SIZE];
        size_t num_hashes;
        struct {
            ptls_hash_algorithm_t *algo;
            ptls_hash_context_t *ctx;
        } hashes[1];
    };

    struct st_ptls_signature_algorithms_t {
        uint16_t list[16]; /* expand? */
        size_t count;
    };

    struct st_ptls_certificate_request_t {
        /**
         * context.base becomes non-NULL when a CertificateRequest is pending for processing
         */
        ptls_iovec_t context;
        struct st_ptls_signature_algorithms_t signature_algorithms;
    };


    struct st_ptls_traffic_protection_t {
        uint8_t secret[PTLS_MAX_DIGEST_SIZE];
        size_t epoch;
        /* the following fields are not used if the key_change callback is set */
        ptls_aead_context_t *aead;
        uint64_t seq;
    };

    struct st_ptls_t {
        /**
         * the context
         */
        ptls_context_t *ctx;

    
        /**
         * key schedule
         */
        ptls_key_schedule_t *key_schedule;

        /**
         * values used for record protection
         */
        struct {
            struct st_ptls_traffic_protection_t dec;
            struct st_ptls_traffic_protection_t enc;
        } traffic_protection;

            
        struct {
            uint8_t *early;
            uint8_t *one_rtt;
        } exporter_master_secret;
        /* flags */
        unsigned is_server : 1;
        unsigned is_psk_handshake : 1;
        unsigned send_change_cipher_spec : 1;
        unsigned needs_key_update : 1;
        unsigned key_update_send_request : 1;
        unsigned skip_tracing : 1;
        /**
         * misc.
         */
        union {
            struct {
                ptls_iovec_t legacy_session_id;
                uint8_t legacy_session_id_buf[32];
                ptls_key_exchange_context_t *key_share_ctx;
                unsigned offered_psk : 1;
                /**
                 * if 1-RTT write key is active
                 */
                unsigned using_early_data : 1;
                struct st_ptls_certificate_request_t certificate_request;
            } client;
            struct {
                uint8_t pending_traffic_secret[PTLS_MAX_DIGEST_SIZE];
                uint32_t early_data_skipped_bytes; /* if not UINT32_MAX, the server is skipping early data */
            } server;
        };
    };

    static const uint8_t zeroes_of_max_digest_size[PTLS_MAX_DIGEST_SIZE] = {0};

    int hkdf_expand_label(ptls_hash_algorithm_t *algo, void *output, size_t outlen, ptls_iovec_t secret, const char *label,
                      ptls_iovec_t hash_value, const char *label_prefix)
    {
        ptls_buffer_t hkdf_label;
        uint8_t hkdf_label_buf[80];
        int ret;

        assert(label_prefix != NULL);

        ptls_buffer_init(&hkdf_label, hkdf_label_buf, sizeof(hkdf_label_buf));

        ptls_buffer_push16(&hkdf_label, (uint16_t)outlen);
        ptls_buffer_push_block(&hkdf_label, 1, {
            ptls_buffer_pushv(&hkdf_label, label_prefix, strlen(label_prefix));
            ptls_buffer_pushv(&hkdf_label, label, strlen(label));
        });
        ptls_buffer_push_block(&hkdf_label, 1, { ptls_buffer_pushv(&hkdf_label, hash_value.base, hash_value.len); });

        ret = ptls_hkdf_expand(algo, output, outlen, secret, ptls_iovec_init(hkdf_label.base, hkdf_label.off));

    Exit:
        ptls_buffer_dispose(&hkdf_label);
        return ret;
    }

    static int key_schedule_extract(ptls_key_schedule_t *sched, ptls_iovec_t ikm)
    {
        int ret;

        if (ikm.base == NULL)
            ikm = ptls_iovec_init(zeroes_of_max_digest_size, sched->hashes[0].algo->digest_size);

        if (sched->generation != 0 &&
            (ret = hkdf_expand_label(sched->hashes[0].algo, sched->secret, sched->hashes[0].algo->digest_size,
                                    ptls_iovec_init(sched->secret, sched->hashes[0].algo->digest_size), "derived",
                                    ptls_iovec_init(sched->hashes[0].algo->empty_digest, sched->hashes[0].algo->digest_size),
                                    sched->hkdf_label_prefix)) != 0)
            return ret;
        ++sched->generation;
        ret = ptls_hkdf_extract(sched->hashes[0].algo, sched->secret,
                                ptls_iovec_init(sched->secret, sched->hashes[0].algo->digest_size), ikm);
        return ret;
    }

    static void key_schedule_free(ptls_key_schedule_t *sched)
    {
        size_t i;
        ptls_clear_memory(sched->secret, sizeof(sched->secret));
        for (i = 0; i != sched->num_hashes; ++i)
            sched->hashes[i].ctx->final(sched->hashes[i].ctx, NULL, PTLS_HASH_FINAL_MODE_FREE);
        free(sched);
    }

    static int calc_verify_data(void *output, ptls_key_schedule_t *sched, const void *secret)
    {
        ptls_hash_context_t *hmac;
        uint8_t digest[PTLS_MAX_DIGEST_SIZE];
        int ret;
        std::cerr << "calc_verify_data 1" <<"\n";
        if ((ret = hkdf_expand_label(sched->hashes[0].algo, digest, sched->hashes[0].algo->digest_size,
                                    ptls_iovec_init(secret, sched->hashes[0].algo->digest_size), "finished", ptls_iovec_init(NULL, 0),
                                    sched->hkdf_label_prefix)) != 0)
            return ret;
        
        std::cerr << "calc_verify_data 2" <<"\n";

        if ((hmac = ptls_hmac_create(sched->hashes[0].algo, digest, sched->hashes[0].algo->digest_size)) == NULL) {
            ptls_clear_memory(digest, sizeof(digest));
            return PTLS_ERROR_NO_MEMORY;
        }

        sched->hashes[0].ctx->final(sched->hashes[0].ctx, digest, PTLS_HASH_FINAL_MODE_SNAPSHOT);
        hmac->update(hmac, digest, sched->hashes[0].algo->digest_size);
        ptls_clear_memory(digest, sizeof(digest));
        hmac->final(hmac, output, PTLS_HASH_FINAL_MODE_FREE);
        std::cerr << "calc_verify_data 3" <<"\n";
        return 0;
    }


    static ptls_key_schedule_t *key_schedule_new(ptls_cipher_suite_t *preferred, ptls_cipher_suite_t **offered,
                                                const char *hkdf_label_prefix)
    {
        std::cerr << "compute_binder key_schedule_new 0" <<"\n";
    #define FOREACH_HASH(block)                                                                                                        \
        do {                                                                                                                           \
            ptls_cipher_suite_t *cs;                                                                                                   \
            if ((cs = preferred) != NULL) {                                                                                            \
                block                                                                                                                  \
            }                                                                                                                          \
            if (offered != NULL) {                                                                                                     \
                size_t i, j;                                                                                                           \
                for (i = 0; (cs = offered[i]) != NULL; ++i) {                                                                          \
                    if (preferred == NULL || cs->hash != preferred->hash) {                                                            \
                        for (j = 0; j != i; ++j)                                                                                       \
                            if (cs->hash == offered[j]->hash)                                                                          \
                                break;                                                                                                 \
                        if (j == i) {                                                                                                  \
                            block                                                                                                      \
                        }                                                                                                              \
                    }                                                                                                                  \
                }                                                                                                                      \
            }                                                                                                                          \
        } while (0)

        std::cerr << "compute_binder key_schedule_new 00" <<"\n";

        ptls_key_schedule_t *sched;
        std::cerr << "compute_binder key_schedule_new 1" <<"\n";
        if (hkdf_label_prefix == NULL)
            hkdf_label_prefix = PTLS_HKDF_EXPAND_LABEL_PREFIX;

        { /* allocate */
            size_t num_hashes = 0;
            FOREACH_HASH({ ++num_hashes; });
            //int ret = 0; sched = malloc(...)
            std::cerr << "compute_binder key_schedule_new 2" <<"\n";
            if ((sched = static_cast<ptls_key_schedule_t *>(malloc(offsetof(ptls_key_schedule_t, hashes) + sizeof(sched->hashes[0]) * num_hashes))) == NULL)
                return NULL;
            std::cerr << "compute_binder key_schedule_new 3" <<"\n";
            *sched = (ptls_key_schedule_t){0, hkdf_label_prefix};
        }
        std::cerr << "compute_binder key_schedule_new 4" <<"\n";
        /* setup the hash algos and contexts */
        FOREACH_HASH({
            sched->hashes[sched->num_hashes].algo = cs->hash;
            if ((sched->hashes[sched->num_hashes].ctx = cs->hash->create()) == NULL)
                goto Fail;
            ++sched->num_hashes;
        });
        std::cerr << "compute_binder key_schedule_new 5" <<"\n";
        return sched;
    Fail:
        key_schedule_free(sched);
        return NULL;

    #undef FOREACH_HASH
    }

    static uint64_t ntoh64(const uint8_t *src)
    {
        return (uint64_t)src[0] << 56 | (uint64_t)src[1] << 48 | (uint64_t)src[2] << 40 | (uint64_t)src[3] << 32 |
            (uint64_t)src[4] << 24 | (uint64_t)src[5] << 16 | (uint64_t)src[6] << 8 | src[7];
    }


    static int derive_secret_with_hash(ptls_key_schedule_t *sched, void *secret, const char *label, const uint8_t *hash)
    {
        //ptls_
        int ret = hkdf_expand_label(sched->hashes[0].algo, secret, sched->hashes[0].algo->digest_size,
                                    ptls_iovec_init(sched->secret, sched->hashes[0].algo->digest_size), label,
                                    ptls_iovec_init(hash, sched->hashes[0].algo->digest_size), sched->hkdf_label_prefix);
        return ret;
    }

    static int derive_secret(ptls_key_schedule_t *sched, void *secret, const char *label)
    {
        uint8_t hash_value[PTLS_MAX_DIGEST_SIZE];

        sched->hashes[0].ctx->final(sched->hashes[0].ctx, hash_value, PTLS_HASH_FINAL_MODE_SNAPSHOT);
        int ret = derive_secret_with_hash(sched, secret, label, hash_value);
        ptls_clear_memory(hash_value, sizeof(hash_value));
        return ret;
    }

    static int derive_secret_with_empty_digest(ptls_key_schedule_t *sched, void *secret, const char *label)
    {
        return derive_secret_with_hash(sched, secret, label, sched->hashes[0].algo->empty_digest);
    }

    static int derive_resumption_secret(ptls_key_schedule_t *sched, uint8_t *secret, ptls_iovec_t nonce)
    {
        int ret;

        if ((ret = derive_secret(sched, secret, "res master")) != 0)
            goto Exit;
        if ((ret = hkdf_expand_label(sched->hashes[0].algo, secret, sched->hashes[0].algo->digest_size,
                                    ptls_iovec_init(secret, sched->hashes[0].algo->digest_size), "resumption", nonce,
                                    sched->hkdf_label_prefix)) != 0)
            goto Exit;

    Exit:
        if (ret != 0)
            ptls_clear_memory(secret, sched->hashes[0].algo->digest_size);
        return ret;
    }


  /*  void ptls__key_schedule_update_hash(ptls_key_schedule_t *sched, const uint8_t *msg, size_t msglen)
    {
        size_t i;
        for (i = 0; i != sched->num_hashes; ++i)
            sched->hashes[i].ctx->update(sched->hashes[i].ctx, msg, msglen);
    }*/

    //     static int setup_traffic_protection(ptls_t *tls, int is_enc, const char *secret_label, size_t epoch, int skip_notify)
    // {
    //     static const char *log_labels[2][4] = {
    //         {NULL, "CLIENT_EARLY_TRAFFIC_SECRET", "CLIENT_HANDSHAKE_TRAFFIC_SECRET", "CLIENT_TRAFFIC_SECRET_0"},
    //         {NULL, NULL, "SERVER_HANDSHAKE_TRAFFIC_SECRET", "SERVER_TRAFFIC_SECRET_0"}};
    //     struct st_ptls_traffic_protection_t *ctx = is_enc ? &tls->traffic_protection.enc : &tls->traffic_protection.dec;

    //     if (secret_label != NULL) {
    //         int ret;
    //         if ((ret = derive_secret(tls->key_schedule, ctx->secret, secret_label)) != 0)
    //             return ret;
    //     }

    //     ctx->epoch = epoch;

    //     /* special path for applications having their own record layer */
    //     if (tls->ctx->update_traffic_key != NULL) {
    //         if (skip_notify)
    //             return 0;
    //         return tls->ctx->update_traffic_key->cb(tls->ctx->update_traffic_key, tls, is_enc, epoch, ctx->secret);
    //     }

    //     if (ctx->aead != NULL)
    //         ptls_aead_free(ctx->aead);
    //     if ((ctx->aead = ptls_aead_new(tls->cipher_suite->aead, tls->cipher_suite->hash, is_enc, ctx->secret,
    //                                 tls->ctx->hkdf_label_prefix__obsolete)) == NULL)
    //         return PTLS_ERROR_NO_MEMORY; /* TODO obtain error from ptls_aead_new */
    //     ctx->seq = 0;

    //     // log_secret(tls, log_labels[ptls_is_server(tls) == is_enc][epoch],
    //     //         ptls_iovec_init(ctx->secret, tls->key_schedule->hashes[0].algo->digest_size));

    //     return 0;
    // }



    void quic_set_key_from_secret(ptls_cipher_suite_t * cipher, int is_enc, quic_crypto_context_t * ctx, const void *secret)
    {
        if (is_enc) {
             ctx->aead_encrypt = aead_from_secret(cipher, is_enc, secret);
             ctx->pn_enc =  pn_enc_from_secret(cipher, is_enc, secret);
        } else {
            ctx->aead_decrypt = aead_from_secret(cipher, is_enc, secret);
            ctx->pn_dec = pn_enc_from_secret(cipher, is_enc, secret);
        }
    }


    int quic_update_traffic_key_callback(ptls_update_traffic_key_t * self, ptls_t *tls, int is_enc, size_t epoch, const void *secret)
    {
	    static const char *log_labels[2][4] = {
            {NULL, "CLIENT_EARLY_TRAFFIC_SECRET", "CLIENT_HANDSHAKE_TRAFFIC_SECRET", "CLIENT_TRAFFIC_SECRET_0"},
            {NULL, NULL, "SERVER_HANDSHAKE_TRAFFIC_SECRET", "SERVER_TRAFFIC_SECRET_0"}};
	    const char * keylogfile = getenv("SSLKEYLOGFILE");
        const char * keylogfile_0rtt = getenv("ZRTTSSLKEYLOGFILE");
        //const char * is_zrtt = getenv("ZERORTT_TEST");
	    FILE *fp;
        FILE *fp_0rtt;
        const char *secret_label = log_labels[ptls_is_server(tls) == is_enc][epoch];
        std::cerr << "quic_update_traffic_key_callback "<< secret_label <<"\n";
        std::cerr << "quic_update_traffic_key_callback "<< secret <<"\n";
        if(keylogfile != NULL) {
            fp = fopen(keylogfile,"a");
            fprintf(fp, "%s ", secret_label);
            ptls_iovec_t crandom = ptls_get_client_random(tls);
            for (int i = 0 ; i < crandom.len ; i++) {
                fprintf(fp, "%02hhx", crandom.base[i]);
            }
            fprintf(fp, " ");
	    }
        if(keylogfile_0rtt != NULL && !is_rtt) {
            const char *secret_label = log_labels[ptls_is_server(tls) == is_enc][epoch];
            if(strcmp(secret_label, "SERVER_HANDSHAKE_TRAFFIC_SECRET") == 0) {
                fp_0rtt = fopen(keylogfile_0rtt,"w"); //erase
                fprintf(fp_0rtt, "%s", "");
                fclose(fp_0rtt);
            }
            fp_0rtt = fopen(keylogfile_0rtt,"a"); //erase
            fprintf(fp_0rtt, "%s ", secret_label);
            ptls_iovec_t crandom = ptls_get_client_random(tls);
            for (int i = 0 ; i < crandom.len ; i++) {
                fprintf(fp_0rtt, "%02hhx", crandom.base[i]);
            }
            fprintf(fp_0rtt, " ");
	    }
        picotls_connection* cnx = (picotls_connection*)*ptls_get_data_ptr(tls);
        ptls_cipher_suite_t * cipher = ptls_get_cipher(tls);

        if(keylogfile != NULL) {
            for (int i = 0 ; i < cipher->hash->digest_size ; i++) {
                fprintf(fp, "%02hhx", ((uint8_t *) secret)[i]);
            }
            fprintf(fp, "\n");
        }
        if(keylogfile_0rtt != NULL && !is_rtt) {
            for (int i = 0 ; i < cipher->hash->digest_size ; i++) {
                fprintf(fp_0rtt, "%02hhx", ((uint8_t *) secret)[i]);
            }
            fprintf(fp_0rtt, "\n");
        }

        quic_set_key_from_secret(cipher, is_enc, &cnx->crypto_context[epoch], secret);
        if (cnx->crypto_context[epoch].aead_encrypt && cnx->crypto_context[epoch].aead_decrypt) {
            cnx->cb.use(cnx->id,epoch);
        }

        if(keylogfile != NULL) {
            fclose(fp);
        }
        if(keylogfile_0rtt != NULL && !is_rtt) {
            fclose(fp_0rtt);
        }
        return 0;
    }

    // This additional mess sets the initial traffic keys

    void bail(int ret, const char *msg) {
        if (ret) {
            std::cerr << msg;
            exit(1);
        }
    }

    void vec_to_ptls_iovec(ptls_iovec_t &res, const `bytes` &vec) {
        res.base = new uint8_t[vec.size()];
        std::copy(vec.begin(),vec.end(),res.base);
        res.len = vec.size();
    }  
    
    void vec_to_ptls_iovec(ptls_iovec_t &res, uint8_t* vec) {
        res.base = new uint8_t[sizeof(vec)];
        for(int i = 0; i < sizeof(vec); i++)
            res.base[i] = vec[i];
        //std::copy(&vec[0],vec[sizeof(vec)-1],res.base);
        res.len = sizeof(vec);
    }

    /**
     * @brief from https://gitlab.com/wireshark/wireshark/-/blob/master/wsutil/str_util.c
     * 
     * @param ch 
     * @return int 
     */
    int
    ws_xton(char ch)
    {
        switch (ch) {
            case '0': return 0;
            case '1': return 1;
            case '2': return 2;
            case '3': return 3;
            case '4': return 4;
            case '5': return 5;
            case '6': return 6;
            case '7': return 7;
            case '8': return 8;
            case '9': return 9;
            case 'a':  case 'A': return 10;
            case 'b':  case 'B': return 11;
            case 'c':  case 'C': return 12;
            case 'd':  case 'D': return 13;
            case 'e':  case 'E': return 14;
            case 'f':  case 'F': return 15;
            default: return -1;
        }
    }
    
    int 
    set_client_random(ptls_context_t* ctx) 
    {
        std::cerr << "set_client_random start\n";
        int ret = 0;

        char ch;
        FILE *fp;
        size_t len = 0;
        ssize_t read;
        char * line = NULL;

        const char * keylogfile_0rtt = getenv("ZRTTSSLKEYLOGFILE");
        if(keylogfile_0rtt != NULL) {
            fp = fopen(keylogfile_0rtt, "r"); // read mode
            if (fp == NULL) {
                perror("Error while opening the file.\n");
                exit(EXIT_FAILURE);
            }
            read = getline(&line, &len, fp);
            int i = 0;
            // std::cerr << "Retrieved line of length " << read << std::endl;
            // std::cerr << line << std::endl;
            char *token = strtok(line, " ");
            char label[100];
            strcpy(label, token);
            std::cerr <<  "\n-------------------------------------"  << std::endl;
            std::cerr << "Label = " << label << std::endl;
            token = strtok(NULL, " ");
            std::cerr << "Token = " << token << std::endl;
            std::cerr << "Token size = " << strlen(token) << std::endl;
            uint8_t random_client[256];
            memset(random_client, 0, sizeof(random_client));
            /*for (int i = 0 ; i < PTLS_HELLO_RANDOM_SIZE ; i++) {
                //secret[i] = ((uint8_t *) token)[i];
                 std::cerr << "token[i] = " << token[i] << std::endl;
                random_client[i] = (uint8_t) token[i];
            }*/
            int hex_len = strlen(token);
            std::cerr << "random_client = \n" << random_client << std::endl;
            std::cerr << "hex_len/2 = " << hex_len/2 << std::endl;
            for (i = 0; i < hex_len/2; i++) {
                int a = ws_xton(token[i*2]);
                int b = ws_xton(token[i*2 + 1]);
                if (a == -1 || b == -1)
                    return -1;
                random_client[i] = a << 4 | b;
                std::cerr << "token[i*2] = " << token[i*2] << std::endl;
                std::cerr << "token[i*2+1] = " << token[i*2+1] << std::endl;
                std::cerr << "random_client[i] = " << random_client[i] << std::endl;
            }
            std::cerr << "random_client = \n" << random_client << std::endl;
            std::cerr << "random_client size = " << PTLS_HELLO_RANDOM_SIZE << std::endl;
            ctx->random_bytes(random_client, PTLS_HELLO_RANDOM_SIZE); // = void(*)
            std::cerr << "set_client_random stop\n";
            fclose(fp);
        } else 
            ret = -1;

        std::cerr << "set_client_random stop\n";
	    return ret;
    }

    /**
     * @brief Set the up 0rtt traffic keys object
     * from https://gitlab.com/wireshark/wireshark/-/blob/master/epan/dissectors/packet-tls-utils.c
     * @param session 
     * @return int 
     *    The exporter value is computed as:
     *      Derive-Secret(Secret, Label, Messages) =
            HKDF-Expand-Label(Secret, Label,
                              Transcript-Hash(Messages), Hash.length)

            TLS-Exporter(label, context_value, key_length) =
                HKDF-Expand-Label(Derive-Secret(Secret, label, ""),
                                    "exporter", Hash(context_value), key_length)

            <=> 

            TLS-Exporter(label, context_value, key_length) =
                HKDF-Expand-Label(HKDF-Expand-Label(Secret, Label, Transcript-Hash(""), Hash.length),
                                    "exporter", Hash(context_value), key_length)

            Where Secret is either the early_exporter_master_secret or the
            exporter_master_secret.  Implementations MUST use the
            exporter_master_secret unless explicitly specified by the
            application.  The early_exporter_master_secret is defined for use in
            settings where an exporter is needed for 0-RTT data.
     */
    int 
    setup_0rtt_traffic_keys(picotls_connection *session)
    {
        std::cerr << "setup_0rtt_traffic_keys start\n";
        int ret = 0;

        char ch;
        FILE *fp;
        size_t len = 0;
        ssize_t read;
        char * line = NULL;

        const char * keylogfile_0rtt = getenv("ZRTTSSLKEYLOGFILE");
        if(keylogfile_0rtt != NULL) {
            fp = fopen(keylogfile_0rtt, "r"); // read mode
            if (fp == NULL) {
                perror("Error while opening the file.\n");
                exit(EXIT_FAILURE);
            }
            while ((read = getline(&line, &len, fp)) != -1) {
                int i = 0;
                // std::cerr << "Retrieved line of length " << read << std::endl;
                // std::cerr << line << std::endl;
                char *token = strtok(line, " ");
                char label[100];
                strcpy(label, token);
                std::cerr <<  "\n-------------------------------------"  << std::endl;
                std::cerr << "Label = " << label << std::endl;
                token = strtok(NULL, " ");
                token = strtok(NULL, " ");
                while (token != NULL) {
                    //picotls_connection* cnx = (picotls_connection*)*ptls_get_data_ptr(session->gs);
                    ptls_cipher_suite_t cipher = { 0, &ptls_openssl_aes128gcm, &ptls_openssl_sha256 };;

                    int level = 1;
                    /*if(strcmp(label, "SERVER_HANDSHAKE_TRAFFIC_SECRET") == 0) {
                        level = 2;
                        i = 0;
                    } else if (strcmp(label, "CLIENT_HANDSHAKE_TRAFFIC_SECRET") == 0) {
                        level = 2;
                        i = 1;
                    } else */if (strcmp(label, "SERVER_TRAFFIC_SECRET_0") == 0) {
                        level = 1;
                        i = 0;
                    } else if (strcmp(label, "CLIENT_TRAFFIC_SECRET_0") == 0) {
                        level = 1;
                        i = 1;
                    }
                    //uint8_t secret[cipher.hash->digest_size];
                    //uint8_t secret[strlen(token)-1];
                    //uint8_t secret[256];
                    //for (int i = 0 ; i < cipher.hash->digest_size ; i++) {
                    /*for (int i = 0 ; i < strlen(token)-1 ; i++) {
                        //secret[i] = ((uint8_t *) token)[i];
                        secret[i] = (uint8_t) token[i];
                    }*/

                    int hex_len = strlen(token) - 1;
                    uint8_t secret[hex_len / 2];
                    for (int j = 0; j < hex_len / 2; j++) {
                        int a = ws_xton(token[j*2]);
                        int b = ws_xton(token[j*2 + 1]);
                        if (a == -1 || b == -1)
                            return -1;
                        secret[j] = a << 4 | b;
                    }  

                    uint8_t blinder[256];

                    ret = ptls_hkdf_expand_label(cipher.hash, blinder, 
                               cipher.aead->ctr_cipher->key_size,
                               ptls_iovec_init(NULL, 0), 
                               "res binder", // "ext binder" | 
                               ptls_iovec_init(NULL, 0),
                               NULL);

                    ptls_iovec_t prk;
                    prk.base = blinder;
                    prk.len = cipher.hash->digest_size;

                    uint8_t early_exporter_master_secret[256];

                    ret = ptls_hkdf_expand_label(cipher.hash, early_exporter_master_secret, 
                               cipher.aead->ctr_cipher->key_size,
                               ptls_iovec_init(NULL, 0), 
                               "c e traffic",
                               ptls_iovec_init(NULL, 0),
                               NULL);

                    std::cerr << "Early Secret = " << early_exporter_master_secret << std::endl;
                    std::cerr << "Early Secret size = " << sizeof(early_exporter_master_secret) << std::endl;
                    std::cerr << "i = " << i << std::endl;
                    std::cerr << "level = " << level << std::endl;
                    std::cerr << "Secret = " << secret << std::endl;
                    std::cerr << "Secret size = " << sizeof(secret) << std::endl;
                    std::cerr << "Token = " << token << std::endl;
                    std::cerr << "Token size = " << strlen(token) << std::endl;

                    std::cerr <<  "-------------------------------------\n"  << std::endl;

                    //if(level == 3) {
                       // if(i == 1) { //server session->is_server
                            quic_set_key_from_secret(&cipher, true  , &session->crypto_context[level], secret);
                       // } else {     //client !session->is_server
                            quic_set_key_from_secret(&cipher, false, &session->crypto_context[level], secret);
                       // } 
                    //}

                    // if (session->crypto_context[level].aead_encrypt && session->crypto_context[level].aead_decrypt) {
                    //     session->cb.use(session->id,level);
                    // }
                    //quic_set_key_from_secret(&cipher, true , &session->crypto_context[level], secret);
                    //quic_set_key_from_secret(&cipher, false , &session->crypto_context[level], secret);
                    
                    token = strtok(NULL, " ");
                }
            }
            fclose(fp);
        } else 
            ret = -1;

        std::cerr << "setup_0rtt_traffic_keys stop\n";
	    return ret;
    }

    /**
     * @brief 
     *      Derive-Secret(Secret, Label, Messages) =
            HKDF-Expand-Label(Secret, Label,
                              Transcript-Hash(Messages), Hash.length)
     */
    int setup_initial_traffic_keys(picotls_connection *session,
                                   const `bytes` &salt_vec,
                                   const `bytes` &ikm_vec)
    {
        std::cerr << "setup_initial_traffic_keys start\n";
        int ret = 0;
        uint8_t master_secret[256]; /* secret_max */
        ptls_cipher_suite_t cipher = { 0, &ptls_openssl_aes128gcm, &ptls_openssl_sha256 };
        ptls_iovec_t salt;
        ptls_iovec_t ikm;
        ptls_iovec_t prk;
        uint8_t client_secret[256];
        uint8_t server_secret[256];
        uint8_t *secret1, *secret2;

        vec_to_ptls_iovec(salt,salt_vec);
        vec_to_ptls_iovec(ikm,ikm_vec);
        ret = ptls_hkdf_extract(cipher.hash, master_secret, salt, ikm);
        bail(ret,"tls: failed to set up initial master secret\n");
        prk.base = master_secret;
        prk.len = cipher.hash->digest_size;
        ret = ptls_hkdf_expand_label(cipher.hash, client_secret, cipher.hash->digest_size,
            prk, QUIC_LABEL_INITIAL_CLIENT, ptls_iovec_init(NULL, 0),NULL);
            // QUIC_LABEL_QUIC_BASE);
        bail(ret,"tls: failed to set up initial client secret\n");
        ret = ptls_hkdf_expand_label(cipher.hash, server_secret, cipher.hash->digest_size,
            prk, QUIC_LABEL_INITIAL_SERVER, ptls_iovec_init(NULL, 0),NULL);
            // QUIC_LABEL_QUIC_BASE);
        bail(ret,"tls: failed to set up initial server secret\n");
        
        // std::cerr << "setup_initial_traffic_keys server_secret " << server_secret << "\n";
        // std::cerr << "setup_initial_traffic_keys server_secret " << sizeof(server_secret) << "\n";
        /*for (int i = 0 ; i < 256 ; i++) 
            std::cerr << (char) server_secret[i];
        std::cerr << "\n";*/
        // std::cerr << "setup_initial_traffic_keys client_secret " << client_secret << "\n";
        // std::cerr << "setup_initial_traffic_keys client_secret " << sizeof(client_secret) << "\n";
        /*for (uint8_t i = 0 ; i < 256 ; i++) 
            std::cerr << (char) client_secret[i];
        std::cerr << "\n";*/
        quic_set_key_from_secret(&cipher, session->is_server, &session->crypto_context[0], server_secret);
        quic_set_key_from_secret(&cipher, !session->is_server, &session->crypto_context[0], client_secret);
        std::cerr << "setup_initial_traffic_keys stop\n";
	    return ret;
    }



    void encrypt_symm(ptls_cipher_context_t *pn_enc, const `bytes` &clear, const `bytes` &iv, `bytes` &cipher) {
        std::vector<uint8_t> bytes;
        bytes.resize(iv.size());
        std::copy(iv.begin(),iv.end(),bytes.begin());
        ptls_cipher_init(pn_enc, &bytes[0]);
        std::vector<uint8_t> input, output;
        input.resize(clear.size());
        std::copy(clear.begin(),clear.end(),input.begin());
        output.resize(clear.size());
        ptls_cipher_encrypt(pn_enc, &output[0], &input[0], input.size());
        cipher.resize(output.size());
        std::copy(output.begin(),output.end(),cipher.begin());
    }

    // Some parameters for picotls as used by picoquic.

    ptls_key_exchange_algorithm_t *picotls_key_exchanges[] = 
        { &ptls_openssl_secp256r1, &ptls_minicrypto_x25519, NULL };

    ptls_cipher_suite_t *picotls_cipher_suites[] = { 
        &ptls_openssl_aes256gcmsha384, &ptls_openssl_aes128gcmsha256,
        &ptls_minicrypto_chacha20poly1305sha256, NULL };

    // Here we process handshake data on a TLS connection. The in_epoch is a picotls
    // epoch. For the initial client handshake, input is null.


    int picotls_do_handshake(picotls_connection *s, size_t in_epoch, void *input, size_t inlen ) {
        size_t epoch_offsets[5] = { 0, 0, 0, 0, 0 };
        struct st_ptls_buffer_t sendbuf;
        ptls_buffer_init(&sendbuf, (void *)"", 0);
        int ret = ptls_handle_message(s->gs, &sendbuf, epoch_offsets, in_epoch, input, inlen, s->hsp);

        if (ret == PTLS_ERROR_IN_PROGRESS) {
            std::cerr << "PICOTLS RETURNED PTLS_ERROR_IN_PROGRESS " << ret << "\n";
        } else if (ret != 0) {
            std::cerr << "PICOTLS RETURNED ERROR: " << ret << "\n";
        }

        // Any generated bytes go to the lower send callback (even in case of error).

        if (sendbuf.off > 0) {
            for (size_t ep = 0; ep < 4; ep++) {
                size_t num_bytes = epoch_offsets[ep+1] - epoch_offsets[ep];
                if (num_bytes) {
                    `bytes` bytes;
                    bytes.resize(num_bytes);
                    std::copy(sendbuf.base+epoch_offsets[ep],sendbuf.base+epoch_offsets[ep+1],bytes.begin());
                    s->cb.ls(s->id,bytes,ep);
                }
            }
        }

	    return ret;
    }

    static int set_sign_certificate_from_key(EVP_PKEY* pkey, ptls_context_t* ctx)
    {
        int ret = 0;
        ptls_openssl_sign_certificate_t* signer;

        signer = (ptls_openssl_sign_certificate_t*)malloc(sizeof(ptls_openssl_sign_certificate_t));

        if (signer == NULL || pkey == NULL) {
            ret = -1;
        } else {
            ret = ptls_openssl_init_sign_certificate(signer, pkey);
            ctx->sign_certificate = &signer->super;
        }

        if (pkey != NULL) {
            EVP_PKEY_free(pkey);
        }

        if (ret != 0 && signer != NULL) {
            free(signer);
        }

        return ret;
    }

    static int set_sign_certificate_from_key_file(char const* keypem, ptls_context_t* ctx)
    {
        int ret = 0;
        BIO* bio = BIO_new_file(keypem, "rb");
        EVP_PKEY *pkey = PEM_read_bio_PrivateKey(bio, NULL, NULL, NULL);
        if (pkey == NULL) {
            ret = -1;
        }
        else {
            ret = set_sign_certificate_from_key(pkey, ctx);
        }
        BIO_free(bio);
        return ret;
    }


    static uint8_t* get_session_ticket(uint8_t* secret)  {
            //free(secret);
            const char * session_file = getenv("STFILE");
            FILE *fp;
            size_t len = 0;
            ssize_t read;
            char * line = NULL;
            if(session_file != NULL) {
                fp = fopen(session_file,"r");
                read = getline(&line, &len, fp);
                fclose(fp);
                bool is_error = false;
                if(line != NULL) { 
                    std::cerr << "get_session_ticket 1 " << line << std::endl;
                    int hex_len = strnlen(line,200)/2;
                    std::cerr << "get_session_ticket hex_len " << hex_len << std::endl;
                    secret = (uint8_t*) malloc(hex_len); //*sizeof(uint8_t)
                    //std::cerr << "get_session_ticket malloced " << sizeof(secret) << std::endl;
                    for (int j = 0; j < hex_len; j++) {
                        int a = ws_xton(line[j*2]);
                        int b = ws_xton(line[j*2 + 1]);
                        if (a == -1 || b == -1) {
                            is_error = true;
                            std::cerr << "get_session_ticket ERROR " << std::endl;
                            //return NULL;
                            secret = NULL;
                            break;
                        }
                        secret[j] = a << 4 | b;
                        // std::cerr << "get_session_ticket a " << a << std::endl;
                        // std::cerr << "get_session_ticket b " << b << std::endl;
                       // std::cerr << "get_session_ticket secret[j] " << secret[j] << std::endl;
                    }  
                    //std::cerr << "get_session_ticket 2 " << secret << std::endl;
                    /*for(int i = (hex_len/2)-1; i >=0 && !is_error; i--)
                        b.push_back(secret[i]);*/
                    //return secret;
                }
            }
            return secret;
    }



>>>

# Here we put any new members of the ivy C++ class. If we have allocated a per-instance
# object, we declared it here anti-quoted. The plugs in the actual member name, which may
# be any array if this is a parameterized instance.

<<< member

    hash_space::hash_map<`cid`,picotls_connection *> `cid_map`; // maps cid's to connections
    tls_callbacks *`cb`;             // the callbacks to ivy

>>>


# Here, we put code to go in the initializer. If this is a
# parameterized instance, then this code will be run in a loop, so we
# have to be careful that any initialization of common objects is
# idempotent.

<<< init

    // Create the callbacks. When you put an
    // action in anti-quotes it creates a function object (a "thunk")
    // that captures the instance environment, in this case including
    // the instance's endpoint id "me".

    `cb` = new tls_callbacks(`lower.send`,`upper.recv`,`upper.alert`,`upper.keys_established`);

>>>


    object impl = {

    # These are the implementations of the interface calls. These
    # operations are synchronous.

    # close the socket

    implement create_no_hs(c:cid, is_server:bool, e:extens) {
        <<< impure

         std::cerr << "create cid = " << c << std::endl;  
        // We create a new picootls session, and add an entry in the cid_map
        // for it.

        ptls_context_t* ctx;
        ctx = new ptls_context_t;
        memset(ctx, 0, sizeof(ptls_context_t));
        /*
        HelloRetryRequest random:
            CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
            C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
        */
        ctx->random_bytes = ptls_openssl_random_bytes;
        ctx->key_exchanges = picotls_key_exchanges; 
        ctx->cipher_suites = picotls_cipher_suites; 
        ctx->send_change_cipher_spec = 0;
        // ctx->hkdf_label_prefix = QUIC_LABEL_QUIC_BASE;
        
        ctx->hkdf_label_prefix__obsolete = NULL;
        ctx->update_traffic_key = new ptls_update_traffic_key_t;
        ctx->update_traffic_key->cb = quic_update_traffic_key_callback;
        ctx->get_time = &ptls_get_time;
        const char * is_zrtt = getenv("ZERORTT_TEST");
        if(is_zrtt == NULL){
            std::cerr << "PROUT 2 " << is_zrtt << std::endl;
            ctx->ticket_lifetime = 0; // no ticket? was: 100000; /* 100,000 seconds, a bit more than one day */
            ctx->require_dhe_on_psk = 1;
        }
        else {
            std::cerr << "PROUT " << is_zrtt << std::endl;
            ctx->ticket_lifetime = 60 * 60 * 24;
            ctx->require_dhe_on_psk = 0;
        }
        ctx->max_early_data_size = 0xFFFFFFFF;
        ctx->omit_end_of_early_data = 1;

        ctx->use_exporter = 1; // master secrets should be recorded
        
        ptls_handshake_properties_t *handshake_properties = new ptls_handshake_properties_t; 
        memset(handshake_properties, 0, sizeof(ptls_handshake_properties_t));
        handshake_properties->collect_extension = tls_collect_extensions_cb;
        handshake_properties->collected_extensions = tls_collected_extensions_cb;
        
        ptls_iovec_t *alpn_vec = new(ptls_iovec_t);  // TODO: will leak this
        
        // h3-x == HTTP/3 over QUIC 
        // hq-x == HTTP/0.9 over QUIC
        alpn_vec->base = (uint8_t*) "hq-29";
        if(const char* env_p = std::getenv("TEST_ALPN")) { 
            std::cerr << "TEST_ALPN " << env_p << std::endl;
            alpn_vec->base = (uint8_t*) env_p;
        }

        alpn_vec->len = strlen((char *)(alpn_vec->base));
        handshake_properties->client.negotiated_protocols.count = 1;
        handshake_properties->client.negotiated_protocols.list  = alpn_vec;

        // add the extensions
        int add = 1;
        const char* env_p = std::getenv("ZERORTT_TEST");
        /*if (!is_server) {
            add = 2;
        } */
        if((env_p != NULL && !is_server)) {  //
            std::cerr << "ZERORTT_TEST " << env_p << std::endl;
            add = 2;
        }

        ptls_raw_extension_t *ptls_exts = new ptls_raw_extension_t[e.size()+add];
        for (unsigned i = 0; i < e.size(); i++) {
            `exten_ser` ser;
	        std::cerr << "etype =" << std::endl;  
            __ser(ser,e[i]);
            unsigned etype = (((unsigned char)(ser.res[0])) << 8) + ((unsigned char)(ser.res[1]));
            unsigned len = (((unsigned char)(ser.res[2])) << 8) + ((unsigned char)(ser.res[3]));
            unsigned char *data = new unsigned char[ser.res.size()-4];
            std::copy(ser.res.begin()+4,ser.res.end(),data);
            ptls_exts[i].type = etype;
            //std::cerr << "etype =" << etype << std::endl;  
            ptls_exts[i].data.base = data;
            //std::cerr << "data =" << data << std::endl;  
            ptls_exts[i].data.len = len;
            //std::cerr << "len =" << len << std::endl;  
            // int eres = gnutls_session_ext_register (session, "ext_name", etype,
            //   GNUTLS_EXT_APPLICATION, gnutls_ext_supp_recv_params,
            //   gnutls_ext_supp_send_params, 0,0,0,0);
            // if (eres != GNUTLS_E_SUCCESS) {
            //     std::cerr << "gnutls_session_ext_register\n";
            //     exit(1);
            // }
        }
        
        // A client MUST provide a "psk_key_exchange_modes" extension if it
        // offers a "pre_shared_key" extension. 
        if((env_p != NULL && !is_server)) {  //env_p != NULL && 
            //Extension: psk_key_exchange_modes (len=2)
            ptls_exts[e.size()].type = 0x2D;
            unsigned char datas [] =  {0x01, 0x01};
            ptls_exts[e.size()].data.base =  datas;
            ptls_exts[e.size()].data.len = 2;

            /*//early_data
            ptls_exts[e.size()+1].type = 0x2A;
            ptls_exts[e.size()+1].data.base = NULL;
            ptls_exts[e.size()+1].data.len = 0;

            //psk
            ptls_exts[e.size()+2].type = 0x29;
            unsigned char data [] =  {
                0x00, 0x6c, 0x00, 0x66, 0x00, 0xff, 0x35, 0x5f, 0x0e, 0x8b, 0x50, 0xe8, 0xcc, 0xb2, 0x94, 0x66,
                0x13, 0xb6, 0x42, 0x93, 0x40, 0x41, 0x43, 0x9c, 0x58, 0x9f, 0xb9, 0x41, 0xed, 0xa7, 0xef, 0xfe,
                0x2f, 0xc0, 0xcc, 0xfb, 0x9f, 0xd8, 0x8b, 0x47, 0x72, 0xb0, 0x74, 0x35, 0xa3, 0x5b, 0x4d, 0xb4,
                0xae, 0xd7, 0xad, 0x57, 0xf6, 0x3a, 0xff, 0x1b, 0xce, 0x1f, 0x37, 0xb2, 0xb4, 0xdd, 0x25, 0xee,
                0xbc, 0xd1, 0xc1, 0x7e, 0x07, 0x8b, 0xee, 0x0d, 0x34, 0xd1, 0xe8, 0xfb, 0x99, 0xc4, 0x29, 0x3e,
                0xdb, 0x20, 0xbd, 0x3b, 0x0e, 0xa3, 0xbe, 0x4c, 0xe4, 0x1c, 0x63, 0x55, 0x3f, 0xc6, 0x2a, 0xc7,
                0xb3, 0x78, 0x90, 0x6d, 0x3a, 0x5a, 0x4b, 0x4a, 0xac, 0xaa, 0x44, 0xae, 0x1c, 0x58, 0x00, 0x21,
                0x20, 0xda, 0x01, 0xaa, 0xa6, 0x02, 0xdd, 0x87, 0xee, 0x2f, 0x9d, 0x5f, 0x66, 0xe5, 0xb9, 0xff,
                0xf6, 0x1f, 0x2b, 0x25, 0xa3, 0xd5, 0x91, 0x28, 0xe7, 0xd1, 0x1c, 0x84, 0xc8, 0xaa, 0x54, 0x9a,
                0x17
            };
            ptls_exts[e.size()+2].data.base = data;
            ptls_exts[e.size()+2].data.len = 145;*/
            
            ptls_exts[e.size()+1].type = 0xffff;
            ptls_exts[e.size()+1].data.base = NULL;
            ptls_exts[e.size()+1].data.len = 0;
        } /*else if (!is_server) {
            //psk
            ptls_exts[e.size()].type = 0x29;
            unsigned char data [] =  {
                0x00, 0x6c, 0x00, 0x66, 0x00, 0xff, 0x35, 0x5f, 0x0e, 0x8b, 0x50, 0xe8, 0xcc, 0xb2, 0x94, 0x66,
                0x13, 0xb6, 0x42, 0x93, 0x40, 0x41, 0x43, 0x9c, 0x58, 0x9f, 0xb9, 0x41, 0xed, 0xa7, 0xef, 0xfe,
                0x2f, 0xc0, 0xcc, 0xfb, 0x9f, 0xd8, 0x8b, 0x47, 0x72, 0xb0, 0x74, 0x35, 0xa3, 0x5b, 0x4d, 0xb4,
                0xae, 0xd7, 0xad, 0x57, 0xf6, 0x3a, 0xff, 0x1b, 0xce, 0x1f, 0x37, 0xb2, 0xb4, 0xdd, 0x25, 0xee,
                0xbc, 0xd1, 0xc1, 0x7e, 0x07, 0x8b, 0xee, 0x0d, 0x34, 0xd1, 0xe8, 0xfb, 0x99, 0xc4, 0x29, 0x3e,
                0xdb, 0x20, 0xbd, 0x3b, 0x0e, 0xa3, 0xbe, 0x4c, 0xe4, 0x1c, 0x63, 0x55, 0x3f, 0xc6, 0x2a, 0xc7,
                0xb3, 0x78, 0x90, 0x6d, 0x3a, 0x5a, 0x4b, 0x4a, 0xac, 0xaa, 0x44, 0xae, 0x1c, 0x58, 0x00, 0x21,
                0x20, 0xda, 0x01, 0xaa, 0xa6, 0x02, 0xdd, 0x87, 0xee, 0x2f, 0x9d, 0x5f, 0x66, 0xe5, 0xb9, 0xff,
                0xf6, 0x1f, 0x2b, 0x25, 0xa3, 0xd5, 0x91, 0x28, 0xe7, 0xd1, 0x1c, 0x84, 0xc8, 0xaa, 0x54, 0x9a,
                0x17
            };
            ptls_exts[e.size()].data.base = data;
            ptls_exts[e.size()].data.len = 145;

            ptls_exts[e.size()+1].type = 0xffff;
            ptls_exts[e.size()+1].data.base = NULL;
            ptls_exts[e.size()+1].data.len = 0;
        } */else {
            ptls_exts[e.size()].type = 0xffff;
            ptls_exts[e.size()].data.base = NULL;
            ptls_exts[e.size()].data.len = 0;
        }

        std::cerr << "ptls_exts =" << ptls_exts << std::endl;  
        for (unsigned i = 0; i < e.size(); i++) {
            std::cerr << "ptls_exts[i].type = " << ptls_exts[i].type << std::endl;  
            std::cerr << "ptls_exts[i].base = " << ptls_exts[i].data.base << std::endl;
            std::cerr << "ptls_exts[i].len = " << ptls_exts[i].data.len << std::endl;
        }
        handshake_properties->additional_extensions = ptls_exts;

        // Read the certificate, if we are a server

        if (is_server) {
            /* Read the certificate file */
            if (ptls_load_certificates(ctx, "leaf_cert.pem") != 0) {
                 std::cerr << "could not load certificate file leaf_cert.pem\n";
                 exit(1);
            } else if(set_sign_certificate_from_key_file("leaf_cert.key", ctx)) {
                std::cerr << "could not load key file leaf_cert.key\n";
                exit(1);
            }
        }

        ptls_t *session;
        session = ptls_new(ctx,is_server ? 1 : 0);
        ptls_set_server_name(session, "servername", strlen("servername"));


        if(const char* env_p = std::getenv("TEST_IMPL")) { 
            std::cerr << "TEST_IMPL " << env_p << std::endl;
            std::cerr << "is_server " << is_server << std::endl;
            if(strncmp(env_p,"quic-go",10) == 0 
                || strncmp(env_p,"quiche",10) == 0 
                   || strncmp(env_p,"lsquic",10) == 0 
                      || strncmp(env_p,"aioquic",10) == 0 || true) //TODO ask why sometime ALPN needed
                if (is_server) {
                        std::cerr << "ptls_set_negotiated_protocol"  << std::endl;
                        std::cerr << "ptls_set_negotiated_protocol"  << std::endl;
                        ptls_set_negotiated_protocol(session, 
                            (const char*) handshake_properties->client.negotiated_protocols.list[0].base, 
                            handshake_properties->client.negotiated_protocols.list[0].len);
                }
                   
        }

        picotls_connection *s = new picotls_connection(c,session, ctx,*`cb`,handshake_properties,is_server);
        *ptls_get_data_ptr(session) = s;        

	    `cid_map`[c] = s;
	    >>>
    }


    implement create(c:cid, is_server:bool, e:extens) {
        <<< impure

        std::cerr << "create cid = " << c << std::endl;  
            
        // We create a new picootls session, and add an entry in the cid_map
        // for it.

        ptls_context_t* ctx;
        ctx = new ptls_context_t;
        memset(ctx, 0, sizeof(ptls_context_t));
        /*
        HelloRetryRequest random:
            CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91
            C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C
        */
        ctx->random_bytes = ptls_openssl_random_bytes;
        ctx->key_exchanges = picotls_key_exchanges; 
        ctx->cipher_suites = picotls_cipher_suites; 
        ctx->send_change_cipher_spec = 0;
        // ctx->hkdf_label_prefix = QUIC_LABEL_QUIC_BASE;
        
        ctx->hkdf_label_prefix__obsolete = NULL;
        ctx->update_traffic_key = new ptls_update_traffic_key_t;
        ctx->update_traffic_key->cb = quic_update_traffic_key_callback;
        ctx->get_time = &ptls_get_time;
        const char * is_zrtt = getenv("ZERORTT_TEST");
        if(is_zrtt == NULL){
            std::cerr << "PROUT 2 " << std::endl;
            ctx->ticket_lifetime = 0; // no ticket? was: 100000; /* 100,000 seconds, a bit more than one day */
            ctx->require_dhe_on_psk = 1;
        }
        else {
            std::cerr << "PROUT " << is_zrtt << std::endl;
            ctx->ticket_lifetime = 60 * 60 * 24;
            ctx->require_dhe_on_psk = 0;
        }
        ctx->max_early_data_size = 0xFFFFFFFF;
        ctx->omit_end_of_early_data = 1;

        std::cerr << "PROUT 3 "  << std::endl;

        //ctx->use_exporter = 1; // master secrets should be recorded
        
        ptls_handshake_properties_t *handshake_properties = new ptls_handshake_properties_t; 
        memset(handshake_properties, 0, sizeof(ptls_handshake_properties_t));
        handshake_properties->collect_extension = tls_collect_extensions_cb;
        handshake_properties->collected_extensions = tls_collected_extensions_cb;

        std::cerr << "PROUT 4 " << std::endl;
        
        ptls_iovec_t *alpn_vec = new(ptls_iovec_t);  // TODO: will leak this
        
        // h3-x == HTTP/3 over QUIC 
        // hq-x == HTTP/0.9 over QUIC
        alpn_vec->base = (uint8_t*) "hq-29";
        if(const char* env_p = std::getenv("TEST_ALPN")) { 
            std::cerr << "TEST_ALPN " << env_p << std::endl;
            alpn_vec->base = (uint8_t*) env_p;
        }

        alpn_vec->len = strlen((char *)(alpn_vec->base));
        handshake_properties->client.negotiated_protocols.count = 1;
        handshake_properties->client.negotiated_protocols.list  = alpn_vec;

        // add the extensions
        int add = 1;
        const char* env_p = std::getenv("ZERORTT_TEST");
        /*if (!is_server) {
            add = 2;
        } */
        if((env_p != NULL && !is_server)) {  //
            std::cerr << "ZERORTT_TEST " << env_p << std::endl;
            add = 2;
        }

        ptls_raw_extension_t *ptls_exts = new ptls_raw_extension_t[e.size()+add];
        for (unsigned i = 0; i < e.size(); i++) {
            `exten_ser` ser;
	        std::cerr << "etype =" << std::endl;  
            __ser(ser,e[i]);
            unsigned etype = (((unsigned char)(ser.res[0])) << 8) + ((unsigned char)(ser.res[1]));
            unsigned len = (((unsigned char)(ser.res[2])) << 8) + ((unsigned char)(ser.res[3]));
            unsigned char *data = new unsigned char[ser.res.size()-4];
            std::copy(ser.res.begin()+4,ser.res.end(),data);
            ptls_exts[i].type = etype;
            std::cerr << "etype =" << etype << std::endl;  
            ptls_exts[i].data.base = data;
            //std::cerr << "data =" << data << std::endl;  
            ptls_exts[i].data.len = len;
            std::cerr << "len =" << len << std::endl;  
            // int eres = gnutls_session_ext_register (session, "ext_name", etype,
            //   GNUTLS_EXT_APPLICATION, gnutls_ext_supp_recv_params,
            //   gnutls_ext_supp_send_params, 0,0,0,0);
            // if (eres != GNUTLS_E_SUCCESS) {
            //     std::cerr << "gnutls_session_ext_register\n";
            //     exit(1);
            // }
        }
        
        // A client MUST provide a "psk_key_exchange_modes" extension if it
        // offers a "pre_shared_key" extension. 
        if((env_p != NULL && !is_server)) {  //env_p != NULL && 
            //Extension: psk_key_exchange_modes (len=2)
            ptls_exts[e.size()].type = 0x2D;
            unsigned char datas [] =  {0x01, 0x01};
            ptls_exts[e.size()].data.base =  datas;
            ptls_exts[e.size()].data.len = 2;

            /*//early_data
            ptls_exts[e.size()+1].type = 0x2A;
            ptls_exts[e.size()+1].data.base = NULL;
            ptls_exts[e.size()+1].data.len = 0;

            //psk
            ptls_exts[e.size()+2].type = 0x29;
            unsigned char data [] =  {
                0x00, 0x6c, 0x00, 0x66, 0x00, 0xff, 0x35, 0x5f, 0x0e, 0x8b, 0x50, 0xe8, 0xcc, 0xb2, 0x94, 0x66,
                0x13, 0xb6, 0x42, 0x93, 0x40, 0x41, 0x43, 0x9c, 0x58, 0x9f, 0xb9, 0x41, 0xed, 0xa7, 0xef, 0xfe,
                0x2f, 0xc0, 0xcc, 0xfb, 0x9f, 0xd8, 0x8b, 0x47, 0x72, 0xb0, 0x74, 0x35, 0xa3, 0x5b, 0x4d, 0xb4,
                0xae, 0xd7, 0xad, 0x57, 0xf6, 0x3a, 0xff, 0x1b, 0xce, 0x1f, 0x37, 0xb2, 0xb4, 0xdd, 0x25, 0xee,
                0xbc, 0xd1, 0xc1, 0x7e, 0x07, 0x8b, 0xee, 0x0d, 0x34, 0xd1, 0xe8, 0xfb, 0x99, 0xc4, 0x29, 0x3e,
                0xdb, 0x20, 0xbd, 0x3b, 0x0e, 0xa3, 0xbe, 0x4c, 0xe4, 0x1c, 0x63, 0x55, 0x3f, 0xc6, 0x2a, 0xc7,
                0xb3, 0x78, 0x90, 0x6d, 0x3a, 0x5a, 0x4b, 0x4a, 0xac, 0xaa, 0x44, 0xae, 0x1c, 0x58, 0x00, 0x21,
                0x20, 0xda, 0x01, 0xaa, 0xa6, 0x02, 0xdd, 0x87, 0xee, 0x2f, 0x9d, 0x5f, 0x66, 0xe5, 0xb9, 0xff,
                0xf6, 0x1f, 0x2b, 0x25, 0xa3, 0xd5, 0x91, 0x28, 0xe7, 0xd1, 0x1c, 0x84, 0xc8, 0xaa, 0x54, 0x9a,
                0x17
            };
            ptls_exts[e.size()+2].data.base = data;
            ptls_exts[e.size()+2].data.len = 145;*/
            
            ptls_exts[e.size()+1].type = 0xffff;
            ptls_exts[e.size()+1].data.base = NULL;
            ptls_exts[e.size()+1].data.len = 0;
        } /*else if (!is_server) {
            //psk
            ptls_exts[e.size()].type = 0x29;
            unsigned char data [] =  {
                0x00, 0x6c, 0x00, 0x66, 0x00, 0xff, 0x35, 0x5f, 0x0e, 0x8b, 0x50, 0xe8, 0xcc, 0xb2, 0x94, 0x66,
                0x13, 0xb6, 0x42, 0x93, 0x40, 0x41, 0x43, 0x9c, 0x58, 0x9f, 0xb9, 0x41, 0xed, 0xa7, 0xef, 0xfe,
                0x2f, 0xc0, 0xcc, 0xfb, 0x9f, 0xd8, 0x8b, 0x47, 0x72, 0xb0, 0x74, 0x35, 0xa3, 0x5b, 0x4d, 0xb4,
                0xae, 0xd7, 0xad, 0x57, 0xf6, 0x3a, 0xff, 0x1b, 0xce, 0x1f, 0x37, 0xb2, 0xb4, 0xdd, 0x25, 0xee,
                0xbc, 0xd1, 0xc1, 0x7e, 0x07, 0x8b, 0xee, 0x0d, 0x34, 0xd1, 0xe8, 0xfb, 0x99, 0xc4, 0x29, 0x3e,
                0xdb, 0x20, 0xbd, 0x3b, 0x0e, 0xa3, 0xbe, 0x4c, 0xe4, 0x1c, 0x63, 0x55, 0x3f, 0xc6, 0x2a, 0xc7,
                0xb3, 0x78, 0x90, 0x6d, 0x3a, 0x5a, 0x4b, 0x4a, 0xac, 0xaa, 0x44, 0xae, 0x1c, 0x58, 0x00, 0x21,
                0x20, 0xda, 0x01, 0xaa, 0xa6, 0x02, 0xdd, 0x87, 0xee, 0x2f, 0x9d, 0x5f, 0x66, 0xe5, 0xb9, 0xff,
                0xf6, 0x1f, 0x2b, 0x25, 0xa3, 0xd5, 0x91, 0x28, 0xe7, 0xd1, 0x1c, 0x84, 0xc8, 0xaa, 0x54, 0x9a,
                0x17
            };
            ptls_exts[e.size()].data.base = data;
            ptls_exts[e.size()].data.len = 145;

            ptls_exts[e.size()+1].type = 0xffff;
            ptls_exts[e.size()+1].data.base = NULL;
            ptls_exts[e.size()+1].data.len = 0;
        } */
        else {
            ptls_exts[e.size()].type = 0xffff;
            ptls_exts[e.size()].data.base = NULL;
            ptls_exts[e.size()].data.len = 0;
        }

        for (unsigned i = 0; i < e.size(); i++) {
            std::cerr << "ptls_exts[i].type = " << ptls_exts[i].type << std::endl;  
            //std::cerr << "ptls_exts[i].base = " << ptls_exts[i].data.base << std::endl;
            std::cerr << "ptls_exts[i].len = " << ptls_exts[i].data.len << std::endl;
        }
        handshake_properties->additional_extensions = ptls_exts;

        // Read the certificate, if we are a server

        if (is_server) { //segfautl ??
            int r = ptls_load_certificates(ctx, "leaf_cert.pem");
            std::cerr << "ptls_load_certificates "  << r << std::endl;
            /* Read the certificate file */
            if (r != 0) {
                std::cerr << "could not load certificate file leaf_cert.pem\n";
                exit(1);
            } else if(set_sign_certificate_from_key_file("leaf_cert.key", ctx)) {
                std::cerr << "could not load key file leaf_cert.key\n";
                exit(1);
            }
        }

        ptls_t *session;
        session = ptls_new(ctx,is_server ? 1 : 0);
        ptls_set_server_name(session, "servername", strlen("servername"));

        if(const char* env_p = std::getenv("TEST_IMPL")) { 
            std::cerr << "TEST_IMPL " << env_p << std::endl;
            std::cerr << "is_server " << is_server << std::endl;
            if(strncmp(env_p,"quic-go",10) == 0 
                || strncmp(env_p,"quiche",10) == 0 
                   || strncmp(env_p,"lsquic",10) == 0 
                      || strncmp(env_p,"aioquic",10) == 0) //TODO ask why sometime ALPN needed
                if (is_server) { // && false
                        std::cerr << "ptls_set_negotiated_protocol"  << std::endl;
                        ptls_set_negotiated_protocol(session, 
                            (const char*) handshake_properties->client.negotiated_protocols.list[0].base, 
                            handshake_properties->client.negotiated_protocols.list[0].len);
                } 
        }

        picotls_connection *s = new picotls_connection(c, session, ctx, *`cb`, handshake_properties, is_server);
        *ptls_get_data_ptr(session) = s;        

        std::cerr << "ptls_get_data_ptr"  << std::endl;

	    `cid_map`[c] = s;
        
        std::cerr << "cid_map[c] = s;"  << std::endl;

        // Start the handshake if we are the client. The in_epoch is zero for "initial".

        if (!is_server) 
            picotls_do_handshake(s,0,0,0);
        >>>
    }

    implement create_0rtt(c:cid, is_server:bool) {
        <<< impure

        std::cerr << "create cid = " << c << std::endl;  
        is_rtt = true;
            
        // We create a new picootls session, and add an entry in the cid_map
        // for it.

        ptls_context_t* ctx;
        ctx = new ptls_context_t;
        memset(ctx, 0, sizeof(ptls_context_t));
        ctx->random_bytes = ptls_openssl_random_bytes;
        //set_client_random(ctx);
        ctx->key_exchanges = picotls_key_exchanges; 
        ctx->cipher_suites = picotls_cipher_suites; 
        ctx->send_change_cipher_spec = 0;
        // ctx->hkdf_label_prefix = QUIC_LABEL_QUIC_BASE;
        
        ctx->hkdf_label_prefix__obsolete = NULL;
        ctx->update_traffic_key = new ptls_update_traffic_key_t;
        ctx->update_traffic_key->cb = quic_update_traffic_key_callback;
        ctx->get_time = &ptls_get_time;
        const char * is_zrtt = getenv("ZERORTT_TEST");
        if(is_zrtt == NULL){
            ctx->ticket_lifetime = 0; // no ticket? was: 100000; /* 100,000 seconds, a bit more than one day */
            ctx->require_dhe_on_psk = 1;
        }
        else {
            std::cerr << "PROUT " << is_zrtt << std::endl;
            ctx->ticket_lifetime = 60 * 60 * 24;
            ctx->require_dhe_on_psk = 0;
        }
        ctx->max_early_data_size = 0xFFFFFFFF;
        ctx->omit_end_of_early_data = 1;

        ctx->use_exporter = 1; // master secrets should be recorded
       
        ptls_handshake_properties_t *handshake_properties = new ptls_handshake_properties_t; 
        memset(handshake_properties, 0, sizeof(ptls_handshake_properties_t));
        handshake_properties->collect_extension = tls_collect_extensions_cb;
        handshake_properties->collected_extensions = tls_collected_extensions_cb;
        
        ptls_iovec_t *alpn_vec = new(ptls_iovec_t);  // TODO: will leak this
        
        // h3-x == HTTP/3 over QUIC 
        // hq-x == HTTP/0.9 over QUIC
        alpn_vec->base = (uint8_t*) "hq-29";
        if(const char* env_p = std::getenv("TEST_ALPN")) { 
            std::cerr << "TEST_ALPN " << env_p << std::endl;
            alpn_vec->base = (uint8_t*) env_p;
        }

        alpn_vec->len = strlen((char *)(alpn_vec->base));
        handshake_properties->client.negotiated_protocols.count = 1;
        handshake_properties->client.negotiated_protocols.list  = alpn_vec;

        //ptls_save_ticket_t* save_ticket = NULL;
        //save_ticket = (ptls_save_ticket_t*)malloc(sizeof(ptls_save_ticket_t) + sizeof(picoquic_quic_t*));
        

        //handshake_properties->client.negotiate_before_key_exchange = 1; //HELLORETRY

        // Read the certificate, if we are a server

        if (is_server) {
            /* Read the certificate file */
            if (ptls_load_certificates(ctx, "leaf_cert.pem") != 0) {
                 std::cerr << "could not load certificate file leaf_cert.pem\n";
                 exit(1);
            } else if(set_sign_certificate_from_key_file("leaf_cert.key", ctx)) {
                std::cerr << "could not load key file leaf_cert.key\n";
                exit(1);
            }
        }

        ptls_t *session;
        session = ptls_new(ctx,is_server ? 1 : 0);
        //session->is_psk_handshake = 1;
        ptls_set_server_name(session, "servername", strlen("servername"));


        if(const char* env_p = std::getenv("TEST_IMPL")) { 
            std::cerr << "TEST_IMPL " << env_p << std::endl;
            std::cerr << "TEST_IMPL " << env_p << std::endl;
            std::cerr << "is_server " << is_server << std::endl;
            if(strncmp(env_p,"quic-go",10) == 0 
                || strncmp(env_p,"quiche",10) == 0 
                   || strncmp(env_p,"lsquic",10) == 0 
                      || strncmp(env_p,"aioquic",10) == 0 || true) //TODO ask why sometime ALPN needed
                if (is_server) {
                        std::cerr << "ptls_set_negotiated_protocol"  << std::endl;
                        std::cerr << "ptls_set_negotiated_protocol"  << std::endl;
                        ptls_set_negotiated_protocol(session, 
                            (const char*) handshake_properties->client.negotiated_protocols.list[0].base, 
                            handshake_properties->client.negotiated_protocols.list[0].len);
                }
                   
        }

        picotls_connection *s = new picotls_connection(c,session,ctx,*`cb`,handshake_properties,is_server);
        *ptls_get_data_ptr(session) = s;  

        // uint8_t *ticket; //ERROR with extension
        // if(s->session_ticket == NULL) {
        //     std::cerr << "XXXXXXXXXXXX"  << "\n";
        //     ticket  = get_session_ticket(ticket); //bytes =
        //     s->session_ticket = ticket;
        // }else {
        //     ticket = s->session_ticket;
        // }
        // // handshake_properties->client.session_ticket.base = ticket;
        // // handshake_properties->client.session_ticket.len = sizeof(ticket);
        // size_t *md;
        // *md = 0;
        // std::cerr << "md"  <<  *md << "\n";
        //handshake_properties->client.max_early_data_size = md;      

	    `cid_map`[c] = s;

        setup_0rtt_traffic_keys(s);
	
        // Start the handshake if we are the client. The in_epoch is zero for "initial".

        // if (!is_server) 
        //     picotls_do_handshake(s,0,0,0);
        >>>
    }

    implement add_extensions(c:cid, is_server:bool, e:extens, he:hextens) {
        <<< impure
        std::cerr << "add_extensions 1 " <<  std::endl;
        picotls_connection *s = `cid_map`[c];
        // add the extensions
        int add = 1;
        const char* env_p = std::getenv("ZERORTT_TEST");
        if(env_p != NULL && !is_server  && false) { 
            std::cerr << "ZERORTT_TEST " << env_p << std::endl;
            add = 4;
        }
        ptls_raw_extension_t *ptls_exts = new ptls_raw_extension_t[e.size()+he.size()];
        for (unsigned i = 0; i < e.size(); i++) {
            `exten_ser` ser;
	        std::cerr << "etype =" << std::endl;  
            __ser(ser,e[i]);
            unsigned etype = (((unsigned char)(ser.res[0])) << 8) + ((unsigned char)(ser.res[1]));
            unsigned len = (((unsigned char)(ser.res[2])) << 8) + ((unsigned char)(ser.res[3]));
            unsigned char *data = new unsigned char[ser.res.size()-4];
            std::copy(ser.res.begin()+4,ser.res.end(),data);
            ptls_exts[i].type = etype;
            std::cerr << "etype =" << etype << std::endl;  
            ptls_exts[i].data.base = data;
            //std::cerr << "data =" << data << std::endl;  
            ptls_exts[i].data.len = len;
            std::cerr << "len =" << len << std::endl;  
            // int eres = gnutls_session_ext_register (session, "ext_name", etype,
            //   GNUTLS_EXT_APPLICATION, gnutls_ext_supp_recv_params,
            //   gnutls_ext_supp_send_params, 0,0,0,0);
            // if (eres != GNUTLS_E_SUCCESS) {
            //     std::cerr << "gnutls_session_ext_register\n";
            //     exit(1);
            // }
        }
        for (unsigned i = 0; i <  he.size(); i++) {
            `exten_ser` ser;
	        std::cerr << "etype =" << std::endl;  
            __ser(ser,he[i]);
            // unsigned char etype = (((unsigned char)(ser.res[0])));
            // unsigned len = (((unsigned char)(ser.res[1])) << 16) + (((unsigned char)(ser.res[2])) << 8) + ((unsigned char)(ser.res[3]));
            // unsigned char *data = new unsigned char[ser.res.size()-4];
            unsigned etype = (((unsigned char)(ser.res[0])) << 8) + ((unsigned char)(ser.res[1]));
            unsigned len = (((unsigned char)(ser.res[2])) << 8) + ((unsigned char)(ser.res[3]));
            unsigned char *data = new unsigned char[ser.res.size()-4];
            std::copy(ser.res.begin()+4,ser.res.end(),data);
            ptls_exts[e.size()+i].type = etype;
            std::cerr << "etype =" << etype << std::endl;  
            ptls_exts[e.size()+i].data.base = data;
            std::cerr << "data =" << data << std::endl;  
            ptls_exts[e.size()+i].data.len = len;
            std::cerr << "len =" << len << std::endl;  
            // int eres = gnutls_session_ext_register (session, "ext_name", etype,
            //   GNUTLS_EXT_APPLICATION, gnutls_ext_supp_recv_params,
            //   gnutls_ext_supp_send_params, 0,0,0,0);
            // if (eres != GNUTLS_E_SUCCESS) {
            //     std::cerr << "gnutls_session_ext_register\n";
            //     exit(1);
            // }
        }

        if(env_p != NULL && !is_server  && false) { 
            //Extension: psk_key_exchange_modes (len=2)
            ptls_exts[e.size()].type = 0x2D;
            unsigned char datas [] =  {0x01, 0x01};
            ptls_exts[e.size()].data.base =  datas;
            ptls_exts[e.size()].data.len = 2;

            //early_data
            ptls_exts[e.size()+1].type = 0x2A;
            ptls_exts[e.size()+1].data.base = NULL;
            ptls_exts[e.size()+1].data.len = 0;

            //psk
            ptls_exts[e.size()+2].type = 0x29;
            unsigned char data [] =  {
                0x00, 0x6c, 0x00, 0x66, 0x00, 0xff, 0x35, 0x5f, 0x0e, 0x8b, 0x50, 0xe8, 0xcc, 0xb2, 0x94, 0x66,
                0x13, 0xb6, 0x42, 0x93, 0x40, 0x41, 0x43, 0x9c, 0x58, 0x9f, 0xb9, 0x41, 0xed, 0xa7, 0xef, 0xfe,
                0x2f, 0xc0, 0xcc, 0xfb, 0x9f, 0xd8, 0x8b, 0x47, 0x72, 0xb0, 0x74, 0x35, 0xa3, 0x5b, 0x4d, 0xb4,
                0xae, 0xd7, 0xad, 0x57, 0xf6, 0x3a, 0xff, 0x1b, 0xce, 0x1f, 0x37, 0xb2, 0xb4, 0xdd, 0x25, 0xee,
                0xbc, 0xd1, 0xc1, 0x7e, 0x07, 0x8b, 0xee, 0x0d, 0x34, 0xd1, 0xe8, 0xfb, 0x99, 0xc4, 0x29, 0x3e,
                0xdb, 0x20, 0xbd, 0x3b, 0x0e, 0xa3, 0xbe, 0x4c, 0xe4, 0x1c, 0x63, 0x55, 0x3f, 0xc6, 0x2a, 0xc7,
                0xb3, 0x78, 0x90, 0x6d, 0x3a, 0x5a, 0x4b, 0x4a, 0xac, 0xaa, 0x44, 0xae, 0x1c, 0x58, 0x00, 0x21,
                0x20, 0xda, 0x01, 0xaa, 0xa6, 0x02, 0xdd, 0x87, 0xee, 0x2f, 0x9d, 0x5f, 0x66, 0xe5, 0xb9, 0xff,
                0xf6, 0x1f, 0x2b, 0x25, 0xa3, 0xd5, 0x91, 0x28, 0xe7, 0xd1, 0x1c, 0x84, 0xc8, 0xaa, 0x54, 0x9a,
                0x17
            };
            ptls_exts[e.size()+2].data.base = data;
            ptls_exts[e.size()+2].data.len = 145;
            
            ptls_exts[e.size()+3].type = 0xffff;
            ptls_exts[e.size()+3].data.base = NULL;
            ptls_exts[e.size()+3].data.len = 0;
        } else {
            ptls_exts[e.size()+he.size()].type = 0xffff;
            ptls_exts[e.size()+he.size()].data.base = NULL;
            ptls_exts[e.size()+he.size()].data.len = 0;
        }

        std::cerr << "ptls_exts =" << ptls_exts << std::endl;  
        for (unsigned i = 0; i < e.size()+he.size(); i++) {
            std::cerr << "ptls_exts[i].type = " << ptls_exts[i].type << std::endl;  
            std::cerr << "ptls_exts[i].base = " << ptls_exts[i].data.base << std::endl;
            std::cerr << "ptls_exts[i].len = " << ptls_exts[i].data.len << std::endl;
        }
       
        s->hsp->additional_extensions = ptls_exts;
        std::cerr << "add_extensions 2 " <<  std::endl;

        size_t epoch_offsets[5] = { 0, 0, 0, 0, 0 };
        struct st_ptls_buffer_t sendbuf;
        ptls_buffer_init(&sendbuf, (void *)"", 0);
        int ret = ptls_handle_message(s->gs, &sendbuf, epoch_offsets, 0, 0, 0, s->hsp);
        s->message=sendbuf;
        >>>
    }

    implement start_handshake(c:cid) {
        <<< impure
        picotls_connection *s = `cid_map`[c];
        std::cerr << "start_handshake 1 " <<  std::endl;
        picotls_do_handshake(s,0,0,0);
        std::cerr << "start_handshake 2 " <<  std::endl;
        >>>
    }

    implement get_session_ticket(c:cid) returns (b:bytes) {
        <<< impure

            const char * session_file = getenv("STFILE");
            FILE *fp;
            size_t len = 0;
            ssize_t read;
            char * line = NULL;
            if(session_file != NULL) {
                fp = fopen(session_file,"r");
                read = getline(&line, &len, fp);
                fclose(fp);
                bool is_error = false;
                if(line != NULL) { 
                    std::cerr << "TEST_ST 1 " << line << std::endl;
                    int hex_len = strlen(line);
                    std::cerr << "TEST_ST hex_len " << hex_len << std::endl;
                    uint8_t secret[hex_len/2];
                    for (int j = 0; j < hex_len/2; j++) {
                        int a = ws_xton(line[j*2]);
                        int b = ws_xton(line[j*2 + 1]);
                        if (a == -1 || b == -1) {
                            is_error = true;
                            std::cerr << "TEST_ST ERROR " << std::endl;
                            break;
                        }
                        secret[j] = a << 4 | b;
                        std::cerr << "TEST_ST a " << a << std::endl;
                        std::cerr << "TEST_ST b " << b << std::endl;
                        std::cerr << "TEST_ST secret[j] " << secret[j] << std::endl;
                    }  
                    std::cerr << "TEST_ST 2 " << secret << std::endl;
                    /*for(int i = (hex_len/2)-1; i >=0 && !is_error; i--)
                        b.push_back(secret[i]);*/
                    for(int i = 0; i < hex_len/2 && !is_error; i++)
                        b.push_back(secret[i]);
                }
            }
        >>>
    }


    implement get_old_retry_token(c:cid) returns (b:stream_data) {
        <<< impure

            const char * session_file = getenv("RTFILE");
            FILE *fp;
            size_t len = 0;
            ssize_t read;
            char * line = NULL;
            if(session_file != NULL) {
                fp = fopen(session_file,"r");
                read = getline(&line, &len, fp);
                fclose(fp);
                bool is_error = false;
                if(line != NULL) { 
                    std::cerr << "RTFILE 1 " << line << std::endl;
                    int hex_len = strlen(line);
                    std::cerr << "RTFILE hex_len " << hex_len << std::endl;
                    uint8_t secret[hex_len/2];
                    for (int j = 0; j < hex_len/2; j++) {
                        int a = ws_xton(line[j*2]);
                        int b = ws_xton(line[j*2 + 1]);
                        if (a == -1 || b == -1) {
                            is_error = true;
                            std::cerr << "a ERROR " << line[j*2] << std::endl;
                            std::cerr << "b ERROR " << line[j*2 + 1] << std::endl;
                            std::cerr << "RTFILE ERROR " << std::endl;
                            break;
                        }
                        secret[j] = a << 4 | b;
                        std::cerr << "RTFILE a " << a << std::endl;
                        std::cerr << "RTFILE b " << b << std::endl;
                        std::cerr << "RTFILE secret[j] " << secret[j] << std::endl;
                    }  
                    std::cerr << "TEST_ST 2 " << secret << std::endl;
                    /*for(int i = (hex_len/2)-1; i >=0 && !is_error; i--)
                        b.push_back(secret[i]);*/
                    for(int i = 0; i < hex_len/2 && !is_error; i++)
                        b.push_back(secret[i]);
                }
            }
        >>>
    }


        implement get_old_new_token(c:cid) returns (b:stream_data) {
        <<< impure

            const char * session_file = getenv("NTFILE");
            FILE *fp;
            size_t len = 0;
            ssize_t read;
            char * line = NULL;
            if(session_file != NULL) {
                fp = fopen(session_file,"r");
                read = getline(&line, &len, fp);
                fclose(fp);
                bool is_error = false;
                if(line != NULL) { 
                    // std::cerr << "NTFILE 1 " << line << std::endl;
                    int hex_len = strlen(line);
                    // std::cerr << "NTFILE hex_len " << hex_len << std::endl;
                    uint8_t secret[hex_len/2];
                    for (int j = 0; j < hex_len/2; j++) {
                        int a = ws_xton(line[j*2]);
                        int b = ws_xton(line[j*2 + 1]);
                        if (a == -1 || b == -1) {
                            is_error = true;
                            std::cerr << "a ERROR " << line[j*2] << std::endl;
                            std::cerr << "b ERROR " << line[j*2 + 1] << std::endl;
                            std::cerr << "NTFILE ERROR " << std::endl;
                            break;
                        }
                        secret[j] = a << 4 | b;
                        // std::cerr << "NTFILE a " << a << std::endl;
                        // std::cerr << "NTFILE b " << b << std::endl;
                        // std::cerr << "NTFILE secret[j] " << secret[j] << std::endl;
                    }  
                    std::cerr << "NTFILE 2 " << secret << std::endl;
                    /*for(int i = (hex_len/2)-1; i >=0 && !is_error; i--)
                        b.push_back(secret[i]);*/
                    for(int i = 0; i < hex_len/2 && !is_error; i++)
                        b.push_back(secret[i]);
                }
            }
        >>>
    }


    implement get_session_lifetime(c:cid) returns (b:stream_pos) {
        <<< impure

            const char * session_file = getenv("STFILE");
            FILE *fp;
            size_t len = 0;
            ssize_t read;
            char * line = NULL;
            uint32_t adder = 0;
            uint32_t obtained_at = 0;
            if(session_file != NULL) {
                fp = fopen(session_file,"r");
                read = getline(&line, &len, fp);
                read = getline(&line, &len, fp);
                bool is_error = false;
                if(line != NULL) { 
                    adder = (uint32_t) std::stoll(line);
                }
                read = getline(&line, &len, fp);
                if(line != NULL) { 
                    obtained_at = (uint32_t) std::stoll(line);
                };
                fclose(fp);
            }

            picotls_connection *s = `cid_map`[c];

            // ptls_context_t* ctx;
            // ctx = new ptls_context_t;
            // memset(ctx, 0, sizeof(ptls_context_t));
            // ctx->get_time = &ptls_get_time;
    
            std::cerr << "get_session_lifetime   1 "  <<  c << "\n";

            std::cerr << s->gs->state << "\n";
            //picotls_connection *s = `cid_map`[c];
            //size_t in_epoch = ptls_get_read_epoch(s->gs);

            std::cerr << "get_session_lifetime   2 "   << s << "\n";
            
            //ptls_context_t * ctx = s->cctx;
            ptls_t *tls = s->gs;
            
            std::cerr << "get_session_lifetime   3 "  << "\n";
            
            ptls_context_t * ctx = ptls_get_context(tls);

            std::cerr << "get_session_lifetime   3 "  << "\n";

            uint8_t *bytes;
            if(s->session_ticket == NULL) {
                std::cerr << "XXXXXXXXXXXX"  << "\n";
                bytes  = get_session_ticket(bytes); //bytes =
                s->session_ticket = bytes;
            } else {
                bytes = s->session_ticket;
            }
            
            

            std::cerr << "get_session_lifetime   4 "   << sizeof(bytes) << "\n";

            uint32_t now = (uint32_t) ctx->get_time->cb(ctx->get_time);

            std::cerr << "get_session_lifetime   5 now "   << now << "\n";

            //uint64_t obtained_at = ntoh64(bytes);

            std::cerr << "get_session_lifetime   6 obtained_at "   << obtained_at << "\n";

            uint32_t age = now - obtained_at;

            std::cerr << "get_session_lifetime   6 age "   << age << "\n";
            
            //b = (uint32_t)(now - obtained_at);

            b = (uint32_t) (age + adder);
            //b = (uint32_t) adder;
        >>>
    }

    implement get_session_lifetime_add(c:cid) returns (b:stream_pos) {
        <<< impure

            const char * session_file = getenv("STFILE");
            FILE *fp;
            size_t len = 0;
            ssize_t read;
            char * line = NULL;
            if(session_file != NULL) {
                fp = fopen(session_file,"r");
                read = getline(&line, &len, fp);
                read = getline(&line, &len, fp);
                read = getline(&line, &len, fp);
                fclose(fp);
                bool is_error = false;
                if(line != NULL) { 
                    b = std::stoll(line);
                }
            }
        >>>
    }
    

    # Computer binder

    implement compute_binder(c:cid) returns (b:bytes) {
        <<< impure

        picotls_connection *s = `cid_map`[c];
        std::cerr << "compute_binder start " << s <<"\n";
        
        //ptls_cipher_suite_t * cipher = ptls_get_cipher(s->gs);
        //ptls_context_t * ctx = ptls_get_context(s->gs);
        std::cerr << "compute_binder   1 " << PTLS_MAX_DIGEST_SIZE << "\n";
        //ptls_context_t * ctx = s->cctx;
        ptls_t *ptls = s->gs;
        std::cerr << "compute_binder  2 " <<"\n";
        //ptls_cipher_suite_t cipher = { 0, &ptls_openssl_aes128gcm, &ptls_openssl_sha256 };
        ptls_cipher_suite_t * cipher = ptls_get_cipher(ptls);
        std::cerr << "compute_binder key_schedule_new start" <<"\n";
        ptls->key_schedule = key_schedule_new(cipher, ptls->ctx->cipher_suites, ptls->ctx->hkdf_label_prefix__obsolete); // s->gs->key_schedule  //ctx->cipher_suites, ctx->hkdf_label_prefix__obsolete
        uint8_t *bytes;
        if(s->session_ticket == NULL) {
            bytes  = get_session_ticket(bytes); //bytes =
            s->session_ticket = bytes;
        } else {
            bytes = s->session_ticket;
        }
        std::cerr << "compute_binder get_session_ticket finish 1"  <<"\n";
        ptls_iovec_t ticket_psk; // = ptls_iovec_init(bytes, sizeof(bytes)); //cipher->hash->digest_size
        vec_to_ptls_iovec(ticket_psk,bytes);
        std::cerr << "compute_binder get_session_ticket finish 2" <<"\n";

        uint8_t resumption_secret[PTLS_MAX_DIGEST_SIZE]; 
        int res4 = derive_resumption_secret(ptls->key_schedule,resumption_secret, ptls_iovec_init(NULL, 0)); //Nonce is empty

        ptls_iovec_t ticketr_psk;
        vec_to_ptls_iovec(ticketr_psk,resumption_secret);
        int ret = key_schedule_extract(ptls->key_schedule,ticket_psk); //ticket_psk
        bail(ret,"tls: failed to key_schedule_extract\n");
        std::cerr << "compute_binder key_schedule_new stop" <<"\n";
        uint8_t binder_key[ptls->key_schedule->hashes[0].algo->digest_size]; // PTLS_MAX_DIGEST_SIZE sched->hashes[0].algo->digest_size+1
        memset(binder_key, 0, sizeof(binder_key));

        //size_t psk_binder_off = emitter->buf->off - (3 + ptls->key_schedule->hashes[0].algo->digest_size);

        //int ret2 = derive_secret_with_empty_digest(ptls->key_schedule, binder_key, "res binder");

        int binder_length1 = ptls->key_schedule->hashes[0].algo->digest_size;
        std::cerr << "compute_binder binder_length1 " << binder_length1 <<"\n";
        
        int ret2 = derive_secret(ptls->key_schedule, binder_key, "res binder");
        bail(ret2,"tls: failed to computer binder\n");
        std::cerr << "compute_binder key_schedule_new " << binder_key <<"\n";

        int binder_length2 = ptls->key_schedule->hashes[0].algo->digest_size;
        std::cerr << "compute_binder binder_length2 " << binder_length2 <<"\n";
        

        ptls_iovec_t uh = ptls_iovec_init(s->message.base, (s->message.base + PTLS_HANDSHAKE_HEADER_SIZE) - s->message.base);
        std::cerr << "compute_binder uh.len " << uh.len <<"\n";
         std::cerr << "compute_binder s->message.off " << s->message.off <<"\n";
        ptls__key_schedule_update_hash(ptls->key_schedule, uh.base, uh.len);

        int binder_length3 = ptls->key_schedule->hashes[0].algo->digest_size;
        std::cerr << "compute_binder binder_length2 " << binder_length3 <<"\n";

        int ret3 = calc_verify_data(binder_key /* to conserve space, reuse binder_key for storing verify_data */, 
                                ptls->key_schedule,
                                binder_key);

        bail(ret3,"tls: failed to computer binder verify\n");
        //b.resize(PTLS_MAX_DIGEST_SIZE);
        // for(int i = sched->hashes[0].algo->digest_size; i >=0  ; i--)
        //     b.push_back(binder_key[i]);
        int i;
        for(i = 0; i < binder_length2; i++) // TODO sizeof(binder_key) sched->hashes[0].algo->digest_size  && (binder_key[i] !=0 || b.size() < 33)
            b.push_back(binder_key[i]);
        //b.push_back(binder_key[i]);
        //std::copy(&binder_key[0], &binder_key[PTLS_MAX_DIGEST_SIZE],b.end());
        //b = binder_key;
        std::cerr << "compute_binder stop" <<"\n";
        >>>
    }

    # Destroy frees a cid
    
    implement destroy(c:cid) {
        <<< impure

        // TODO: actually delete everything here
        picotls_connection *s = `cid_map`[c];
        ptls_free(s->gs);
        `cid_map`.erase(c);


        >>>
    }

    # Set the initial key material.

    implement set_initial_keys(c:cid,salt:bytes,ikm:bytes) {
        <<< impure
        
	    picotls_connection *s = `cid_map`[c];
        setup_initial_traffic_keys(s,salt,ikm);
        std::cerr << "setup_initial_traffic_keys salt: " << salt << "\n";
        std::cerr << "setup_initial_traffic_keys ikm: " << ikm << "\n";
        >>>
    }

    implement set_0rtt_keys(c:cid) {
        <<< impure
	    picotls_connection *s = `cid_map`[c];
        setup_0rtt_traffic_keys(s);
        std::cerr << "set_0rtt_keys: " << "\n";
        >>>
    }

    # Get the cipher initial value size

    implement iv_size(c:cid,l:level) returns (sz:index) {
        <<< impure
        std::cerr << "iv_size start " << "\n";
        std::cerr << "iv_size cid " <<  c << "\n";
        std::cerr << "iv_size level " << l <<  "\n";
	    picotls_connection *s = `cid_map`[c];
        ptls_cipher_context_t *pn_enc = (ptls_cipher_context_t *)(s->crypto_context[l].pn_enc);
        if (!pn_enc)
            pn_enc = (ptls_cipher_context_t *)(s->crypto_context[l].pn_dec);
        if (!pn_enc) {
            std::cerr << "cipher for level " << l << " is not set\n";
            sz = 0;
        }
        else sz = pn_enc->algo->iv_size;
        std::cerr << "iv_size end " << sz << "\n";
        >>>
    }

    implement encrypt_cipher(c:cid,l:level,clear:bytes,iv:bytes,recv:bool) returns (cipher:bytes) {
        <<< impure
        std::cerr << "encrypt_cipher start " << "\n";
        std::cerr << "encrypt_cipher c " << c << "\n";
        std::cerr << "encrypt_cipher iv " << iv << "\n";
	    picotls_connection *s = `cid_map`[c];
        ptls_cipher_context_t *pn_enc;
        if (recv) {
            pn_enc = (ptls_cipher_context_t *)(s->crypto_context[l].pn_dec);
            std::cerr << "encrypt_cipher pn_dec " << pn_enc << "\n";
        } 
        else {
            pn_enc = (ptls_cipher_context_t *)(s->crypto_context[l].pn_enc);
            std::cerr << "encrypt_cipher pn_enc " << pn_enc << "\n";
        }
	    if(pn_enc != 0)
        	encrypt_symm(pn_enc,clear,iv,cipher);
        std::cerr << "encrypt_cipher end " << cipher << "\n";
        >>>
    }

    implement decrypt_cipher(c:cid,l:level,cipher:bytes,iv:bytes) returns (clear:bytes) {
        <<< impure

        std::cerr << "decrypt_cipher start " << "\n";
	    picotls_connection *s = `cid_map`[c];
        ptls_cipher_context_t *pn_enc = (ptls_cipher_context_t *)(s->crypto_context[l].pn_dec);
        encrypt_symm(pn_enc,cipher,iv,clear);
        std::cerr << "decrypt_cipher end " << "\n";

        >>>
    }

    implement save_token(token:stream_data) {
        <<< impure

        unsigned str_d[token.size()];
        for (int i = 0; i < token.size(); i++)
            str_d[i] = token[i];
        const char * session_file = getenv("NTFILE");
        FILE *fp;
        if(session_file != NULL) {
            fp = fopen(session_file,"w");
            for (int i = 0; i < token.size(); i++) {
                //std::cerr <<  "str_d[i] "  << str_d[i] << std::endl;
                //std::cerr <<  "str_d[i] == 0 "  << (str_d[i] == 0) << std::endl;
                if(str_d[i] < 16)
                    fprintf(fp, "0%x", str_d[i]);
                else 
                    fprintf(fp, "%x", str_d[i]);
            }  
            fclose(fp);
        }

        >>>
    }

    implement compute_retry_integrity_tag(odcil: stream_pos, odcid: cid,
                                       pversion: version,
                                       dcil: stream_pos, dcid: cid,
                                       scil: stream_pos, scid: cid,
                                       token : stream_data,
                                       seq:seq_num, h: stream_pos,is_recv: bool) returns (cipher:bytes) {
    <<< impure

        const char * session_file = getenv("RTFILE");
        FILE *fp;
        if(session_file != NULL && is_recv) {
            unsigned str_d[token.size()];
            for (int i = 0; i < token.size(); i++)
                str_d[i] = token[i];
            fp = fopen(session_file,"w");
            for (int i = 0; i < token.size(); i++) {
                //std::cerr <<  "str_d[i] "  << str_d[i] << std::endl;
                //std::cerr <<  "str_d[i] == 0 "  << (str_d[i] == 0) << std::endl;
                if(str_d[i] < 16)
                    fprintf(fp, "0%x", str_d[i]);
                else 
                    fprintf(fp, "%x", str_d[i]);
            }  
            fclose(fp);
        }
        

        uint8_t plaintext[] = "";
        //0xbe 0c 69 0b 9f 66 57 5a 1d 76 6b 54 e3 68 c8 4e : rfc9001
        /*uint8_t key[16] = { 0xbe, 0x0c, 0x69, 0x0b, 0x9f, 0x66, 0x57,
                            0x5a, 0x1d, 0x76, 0x6b, 0x54, 0xe3, 0x68, 
                            0xc8, 0x4e };*/

        //0xcc ce 18 7e d0 9a 09 d0 57 28 15 5a 6c b9 6b e1
        //0xcc 0xce 0x18 0x7e 0xd0 0x9a 0x09 0xd0 0x57 0x28 0x15 0x5a 0x6c 0xb9 0x6b 0xe1 : draft 29
        uint8_t key[16]; 

        //0x4d 0x32 0xec 0xdb 0x2a 0x21 0x33 0xc8 0x41 0xe4 0x04 0x3d 0xf2 0x7d 0x44 0x30
        if(pversion == 0xff00001c) {
            uint8_t key2[16] = { 0x4d, 0x32, 0xec, 0xdb, 0x2a,
                                 0x21, 0x33, 0xc8, 0x41, 0xe4, 
                                 0x04, 0x3d, 0xf2, 0x7d, 0x44, 
                                 0x30 };
            for(int i = 0; i < 16;i++)
                key[i] = key2[i];
        }   
        else if(pversion == 0xff00001d) {
            uint8_t key2[16] = { 0xcc, 0xce, 0x18, 0x7e, 0xd0, 
                                 0x9a, 0x09, 0xd0, 0x57, 0x28, 
                                 0x15, 0x5a, 0x6c, 0xb9, 0x6b, 
                                 0xe1 };
            for(int i = 0; i < 16;i++)
                key[i] = key2[i];
        }
            
        //0x461599d35d632bf2239825bb
        /*uint8_t nonce[12] = { 0x46, 0x15, 0x99, 0xd3, 0x5d, 0x63, 0x2b,
                              0xf2, 0x23, 0x98, 0x25, 0xbb };*/

        //0xe5 0x49 0x30 0xf9 0x7f 0x21 0x36 0xf0 0x53 0x0a 0x8c 0x1c : draft 29
        uint8_t nonce[12];
        //0x4d 0x16 0x11 0xd0 0x55 0x13 0xa5 0x52 0xc5 0x87 0xd5 0x75
        if(pversion == 0xff00001c) {
            uint8_t nonce2[12] = { 0x4d, 0x16, 0x11, 0xd0, 0x55,
                                   0x13, 0xa5, 0x52, 0xc5, 0x87, 
                                   0xd5, 0x75 }; //nonce[12]
            for(int i = 0; i < 12; i++)
                nonce[i] = nonce2[i];
        }    
        else if(pversion == 0xff00001d) {
            uint8_t nonce2[12] = { 0xe5, 0x49, 0x30, 0xf9, 0x7f,
                                   0x21, 0x36, 0xf0, 0x53, 0x0a, 
                                   0x8c, 0x1c }; //nonce[12]
            for(int i = 0; i < 12; i++)
                nonce[i] = nonce2[i];
        }
        
        ptls_aead_context_t *aead = ptls_aead_new_direct(&ptls_openssl_aes128gcm, 1, key, nonce);
        std::cerr << "compute_retry_integrity_tag aead " << aead <<  "\n";
    
        
        uint32_t checksum_length = aead->algo->tag_size;
        std::cerr << "c 3 \n";
        std::cerr << "compute_retry_integrity_tag ptls_aead_context_t " << "\n";

        std::vector<uint8_t> ad;
        //ad.resize(sizeof(odcid));
        std::cerr << "compute_retry_integrity_tag odcil " << odcil << "\n";
        std::cerr << "compute_retry_integrity_tag odcid " << std::hex << odcid << "\n";
        std::cerr << "compute_retry_integrity_tag h " << h << "\n";
        std::cerr << "compute_retry_integrity_tag pversion " << std::hex << pversion << "\n";
        std::cerr << "compute_retry_integrity_tag dcil " << dcil << "\n";
        std::cerr << "compute_retry_integrity_tag dcid " << std::hex << dcid << "\n";
        std::cerr << "compute_retry_integrity_tag scil " <<  scil << "\n";
        std::cerr << "compute_retry_integrity_tag scid " << std::hex << scid << "\n";
        std::cerr << "compute_retry_integrity_tag seq " << std::dec << seq << "\n";
        
        uint8_t pushed;
        std::cerr << "compute_retry_integrity_tag odcil \n";
        ad.push_back(odcil);
        for (int i = odcil-1; i >= 0; --i) {
            pushed = (odcid.val >> (8*i)) & 0xff;
            std::cerr << std::to_string(pushed) << " ";
            ad.push_back(pushed);  
        }
        std::cerr << "\n";
        ad.push_back(h);
        std::cerr << "compute_retry_integrity_tag version \n";
        for (int i = 4-1; i >= 0; --i) {
            pushed = (pversion >> (8*i)) & 0xff;
            std::cerr << std::to_string(pushed) << " ";
            ad.push_back(pushed);
        } 
        std::cerr << "\n";
        std::cerr << "compute_retry_integrity_tag dcid \n";
        ad.push_back(dcil);
        for (int i = dcil-1; i >= 0; --i) {
            pushed = (dcid.val >> (8*i)) & 0xff;
            std::cerr << std::to_string(pushed) << " ";
            ad.push_back(pushed); 
        }
        std::cerr << "\n";
        std::cerr << "compute_retry_integrity_tag scid \n";
        ad.push_back(scil); //scil
        for (int i = scil-1; i >= 0; --i) {
            pushed = (scid.val >> (8*i)) & 0xff;
            std::cerr << std::to_string(pushed) << " ";
            ad.push_back(pushed); 
        }
        
        std::cerr << "\n";
        std::cerr << "compute_retry_integrity_tag token size: " << token.size()  << "\n";
        for (unsigned i = 0; i < token.size(); i++) {
            std::cerr << std::hex << token[i] << ' ';
            ad.push_back(token[i]);
        }

        std::cerr << "\n";
        //std::copy(token.begin(),token.end(),ad.end());

        std::vector<uint8_t> bytes;
        bytes.resize(ad.size());

        std::cerr << "compute_retry_integrity_tag ad size: " << std::dec << ad.size()  << "\n";
        std::cerr << "\n";

        std::copy(ad.begin(),ad.end(),bytes.begin());
        std::cerr << "compute_retry_integrity_tag bytes size: " << std::dec << bytes.size()  << "\n";
        std::cerr << "\n";

        std::vector<uint8_t> output;
        output.resize(16);

        std::cerr << "compute_retry_integrity_tag output size: " << std::dec << output.size()  << "\n";
        size_t encrypted = ptls_aead_encrypt(aead,
          &output[0], &plaintext[0], 0 , seq, //seq, strnlen ?strlen(plaintext)
          &bytes[0], bytes.size());
        
        cipher.resize(output.size());
        std::copy(output.begin(),output.end(),cipher.begin());

        std::cerr << "compute_retry_integrity_tag encrypted size: " << std::dec << encrypted  << "\n";
        std::cerr << "compute_retry_integrity_tag output size: " << std::dec << output.size()  << "\n";
        std::cerr << "\n";

        std::cerr << "compute_retry_integrity_tag finish " << "\n";
    >>>
    }

    implement encrypt_aead(c:cid,l:level,clear:bytes,seq:seq_num,ad:bytes) returns (cipher:bytes) {
        <<< impure
        std::cerr << "encrypt_aead start l " << l << "\n";
        std::cerr << "encrypt_aead start c " << c << "\n";
	    picotls_connection *s = `cid_map`[c];
        ptls_aead_context_t *aead = (ptls_aead_context_t *)(s->crypto_context[l].aead_encrypt);
        std::cerr << "encrypt_aead aead " << aead << "\n";
        uint32_t checksum_length = aead->algo->tag_size;
        std::vector<uint8_t> bytes;
        bytes.resize(ad.size());
        std::copy(ad.begin(),ad.end(),bytes.begin());
        std::vector<uint8_t> input, output;
        input.resize(clear.size());
        std::copy(clear.begin(),clear.end(),input.begin());
        output.resize(clear.size() + checksum_length);
        std::cerr << "encrypt_aead encrypted  1" << "\n";
        size_t encrypted = ptls_aead_encrypt(aead,
          &output[0], &input[0], input.size(), seq,
          &bytes[0], bytes.size());
        std::cerr << "encrypt_aead encrypted " << encrypted << "\n";
        cipher.resize(output.size());
        std::copy(output.begin(),output.end(),cipher.begin());
        std::cerr << "encrypt_aead finish " << "\n";
        >>>
    }

    implement decrypt_aead(c:cid,l:level,cipher:bytes,seq:seq_num,ad:bytes)
    returns (res:decrypt_result) {
        <<< impure
        std::cerr << "decrypt_aead start " << "\n";
        std::cerr << "decrypt_aead ad " << ad.size() <<  "\n";
	    picotls_connection *s = `cid_map`[c];
        ptls_aead_context_t *aead = (ptls_aead_context_t *)(s->crypto_context[l].aead_decrypt);
        std::cerr << "aead == " << aead << "\n";
	    if(aead != 0) {
	        uint32_t checksum_length = aead->algo->tag_size;
            std::cerr << "checksum_length == " << checksum_length << "\n";
            std::vector<uint8_t> bytes;
            bytes.resize(ad.size());
            std::copy(ad.begin(),ad.end(),bytes.begin());

            std::cerr << "seq == " << seq << "\n";
            std::cerr << "bytes.size() == " << bytes.size() << "\n";

            std::vector<uint8_t> input, output;
            input.resize(cipher.size());
            std::copy(cipher.begin(),cipher.end(),input.begin());
            output.resize(cipher.size() - checksum_length);
            size_t decrypted = ptls_aead_decrypt(aead,
                                                &output[0], 
                                                &input[0], 
                                                input.size(), 
                                                seq,
                                                &bytes[0], bytes.size());
            res.ok = decrypted <= input.size();
            std::cerr << "decrypted <= input.size() == " << (decrypted <= input.size()) << "\n";
            if (res.ok) {
                res.data.resize(output.size());
                std::copy(output.begin(),output.end(),res.data.begin());
            }
        } else {
            res.ok = false;
        }
        std::cerr << "decrypt_aead finish " << "\n";
        >>>
    }


    # upper.send is called with application data to be transmitted to the peer.

    implement upper.send(c:cid,data:bytes) {
        <<< impure
        // TODO: implement this
        //picotls_connection *s = `cid_map`[c];
        std::cerr << "upper.send s "   << "\n";
        >>>
    }

    # lower.recv is called with data received from the peer on the lower interface.

    implement lower.recv(c:cid,data:bytes,lev:lower.level) {
        <<< impure
        picotls_connection *s = `cid_map`[c];
        std::cerr << "lower.recv   s "   << s << "\n";
        std::vector<char> &input = s->input;
        for (unsigned i = 0; i < data.size(); i++) {
            input.push_back(data[i]);
        }
        // TODO: make the epoch a parameter of this call
        // For now, we assume that the epochs come in order
        size_t in_epoch = ptls_get_read_epoch(s->gs);
        picotls_do_handshake(s,in_epoch,&(s->input[0]),s->input.size());
        s->input.clear();
        >>>
    }

    
    trusted isolate iso = this

    attribute test = impl
}
}
